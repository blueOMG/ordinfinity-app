import{b as Sn}from"./base64-js.50a5cdf9.js";import{i as xn}from"./ieee754.44f7831e.js";import{e as Wt,s as kn,a as an}from"./@noble.e49e37f0.js";import{B as un}from"./bn.js.cbcbab7e.js";import{b as ot}from"./bs58.604334a4.js";import{s as or,d as cr,a as ar}from"./borsh.7f5b58c8.js";import{t as ur,a as lr}from"./bigint-buffer.f397246a.js";import{c as ce,s as B,i as je,t as Je,l as X,u as ae,a as w,n as y,b as x,d as k,o as D,e as It,r as An,f as lt,g as hr,h as I}from"./superstruct.d6aadb15.js";import{R as dr}from"./jayson.2096f277.js";import{R as fr,c as pr}from"./rpc-websockets.48fa811c.js";var $={};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(d){const n=Sn,r=xn,s=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;d.Buffer=a,d.SlowBuffer=rt,d.INSPECT_MAX_BYTES=50;const c=2147483647;d.kMaxLength=c,a.TYPED_ARRAY_SUPPORT=u(),!a.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function u(){try{const i=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(i,t),i.foo()===42}catch{return!1}}Object.defineProperty(a.prototype,"parent",{enumerable:!0,get:function(){if(a.isBuffer(this))return this.buffer}}),Object.defineProperty(a.prototype,"offset",{enumerable:!0,get:function(){if(a.isBuffer(this))return this.byteOffset}});function h(i){if(i>c)throw new RangeError('The value "'+i+'" is invalid for option "size"');const t=new Uint8Array(i);return Object.setPrototypeOf(t,a.prototype),t}function a(i,t,e){if(typeof i=="number"){if(typeof t=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return U(i)}return g(i,t,e)}a.poolSize=8192;function g(i,t,e){if(typeof i=="string")return q(i,t);if(ArrayBuffer.isView(i))return A(i);if(i==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof i);if(tt(i,ArrayBuffer)||i&&tt(i.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(tt(i,SharedArrayBuffer)||i&&tt(i.buffer,SharedArrayBuffer)))return b(i,t,e);if(typeof i=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const o=i.valueOf&&i.valueOf();if(o!=null&&o!==i)return a.from(o,t,e);const l=_(i);if(l)return l;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof i[Symbol.toPrimitive]=="function")return a.from(i[Symbol.toPrimitive]("string"),t,e);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof i)}a.from=function(i,t,e){return g(i,t,e)},Object.setPrototypeOf(a.prototype,Uint8Array.prototype),Object.setPrototypeOf(a,Uint8Array);function E(i){if(typeof i!="number")throw new TypeError('"size" argument must be of type number');if(i<0)throw new RangeError('The value "'+i+'" is invalid for option "size"')}function F(i,t,e){return E(i),i<=0?h(i):t!==void 0?typeof e=="string"?h(i).fill(t,e):h(i).fill(t):h(i)}a.alloc=function(i,t,e){return F(i,t,e)};function U(i){return E(i),h(i<0?0:z(i)|0)}a.allocUnsafe=function(i){return U(i)},a.allocUnsafeSlow=function(i){return U(i)};function q(i,t){if((typeof t!="string"||t==="")&&(t="utf8"),!a.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const e=wt(i,t)|0;let o=h(e);const l=o.write(i,t);return l!==e&&(o=o.slice(0,l)),o}function R(i){const t=i.length<0?0:z(i.length)|0,e=h(t);for(let o=0;o<t;o+=1)e[o]=i[o]&255;return e}function A(i){if(tt(i,Uint8Array)){const t=new Uint8Array(i);return b(t.buffer,t.byteOffset,t.byteLength)}return R(i)}function b(i,t,e){if(t<0||i.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(i.byteLength<t+(e||0))throw new RangeError('"length" is outside of buffer bounds');let o;return t===void 0&&e===void 0?o=new Uint8Array(i):e===void 0?o=new Uint8Array(i,t):o=new Uint8Array(i,t,e),Object.setPrototypeOf(o,a.prototype),o}function _(i){if(a.isBuffer(i)){const t=z(i.length)|0,e=h(t);return e.length===0||i.copy(e,0,0,t),e}if(i.length!==void 0)return typeof i.length!="number"||Ct(i.length)?h(0):R(i);if(i.type==="Buffer"&&Array.isArray(i.data))return R(i.data)}function z(i){if(i>=c)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+c.toString(16)+" bytes");return i|0}function rt(i){return+i!=i&&(i=0),a.alloc(+i)}a.isBuffer=function(t){return t!=null&&t._isBuffer===!0&&t!==a.prototype},a.compare=function(t,e){if(tt(t,Uint8Array)&&(t=a.from(t,t.offset,t.byteLength)),tt(e,Uint8Array)&&(e=a.from(e,e.offset,e.byteLength)),!a.isBuffer(t)||!a.isBuffer(e))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(t===e)return 0;let o=t.length,l=e.length;for(let f=0,p=Math.min(o,l);f<p;++f)if(t[f]!==e[f]){o=t[f],l=e[f];break}return o<l?-1:l<o?1:0},a.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},a.concat=function(t,e){if(!Array.isArray(t))throw new TypeError('"list" argument must be an Array of Buffers');if(t.length===0)return a.alloc(0);let o;if(e===void 0)for(e=0,o=0;o<t.length;++o)e+=t[o].length;const l=a.allocUnsafe(e);let f=0;for(o=0;o<t.length;++o){let p=t[o];if(tt(p,Uint8Array))f+p.length>l.length?(a.isBuffer(p)||(p=a.from(p)),p.copy(l,f)):Uint8Array.prototype.set.call(l,p,f);else if(a.isBuffer(p))p.copy(l,f);else throw new TypeError('"list" argument must be an Array of Buffers');f+=p.length}return l};function wt(i,t){if(a.isBuffer(i))return i.length;if(ArrayBuffer.isView(i)||tt(i,ArrayBuffer))return i.byteLength;if(typeof i!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof i);const e=i.length,o=arguments.length>2&&arguments[2]===!0;if(!o&&e===0)return 0;let l=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return e;case"utf8":case"utf-8":return Tt(i).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return e*2;case"hex":return e>>>1;case"base64":return ne(i).length;default:if(l)return o?-1:Tt(i).length;t=(""+t).toLowerCase(),l=!0}}a.byteLength=wt;function Rt(i,t,e){let o=!1;if((t===void 0||t<0)&&(t=0),t>this.length||((e===void 0||e>this.length)&&(e=this.length),e<=0)||(e>>>=0,t>>>=0,e<=t))return"";for(i||(i="utf8");;)switch(i){case"hex":return Ce(this,t,e);case"utf8":case"utf-8":return Vt(this,t,e);case"ascii":return _e(this,t,e);case"latin1":case"binary":return Te(this,t,e);case"base64":return Ae(this,t,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Ue(this,t,e);default:if(o)throw new TypeError("Unknown encoding: "+i);i=(i+"").toLowerCase(),o=!0}}a.prototype._isBuffer=!0;function ct(i,t,e){const o=i[t];i[t]=i[e],i[e]=o}a.prototype.swap16=function(){const t=this.length;if(t%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let e=0;e<t;e+=2)ct(this,e,e+1);return this},a.prototype.swap32=function(){const t=this.length;if(t%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let e=0;e<t;e+=4)ct(this,e,e+3),ct(this,e+1,e+2);return this},a.prototype.swap64=function(){const t=this.length;if(t%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let e=0;e<t;e+=8)ct(this,e,e+7),ct(this,e+1,e+6),ct(this,e+2,e+5),ct(this,e+3,e+4);return this},a.prototype.toString=function(){const t=this.length;return t===0?"":arguments.length===0?Vt(this,0,t):Rt.apply(this,arguments)},a.prototype.toLocaleString=a.prototype.toString,a.prototype.equals=function(t){if(!a.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t?!0:a.compare(this,t)===0},a.prototype.inspect=function(){let t="";const e=d.INSPECT_MAX_BYTES;return t=this.toString("hex",0,e).replace(/(.{2})/g,"$1 ").trim(),this.length>e&&(t+=" ... "),"<Buffer "+t+">"},s&&(a.prototype[s]=a.prototype.inspect),a.prototype.compare=function(t,e,o,l,f){if(tt(t,Uint8Array)&&(t=a.from(t,t.offset,t.byteLength)),!a.isBuffer(t))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof t);if(e===void 0&&(e=0),o===void 0&&(o=t?t.length:0),l===void 0&&(l=0),f===void 0&&(f=this.length),e<0||o>t.length||l<0||f>this.length)throw new RangeError("out of range index");if(l>=f&&e>=o)return 0;if(l>=f)return-1;if(e>=o)return 1;if(e>>>=0,o>>>=0,l>>>=0,f>>>=0,this===t)return 0;let p=f-l,S=o-e;const K=Math.min(p,S),N=this.slice(l,f),M=t.slice(e,o);for(let L=0;L<K;++L)if(N[L]!==M[L]){p=N[L],S=M[L];break}return p<S?-1:S<p?1:0};function Gt(i,t,e,o,l){if(i.length===0)return-1;if(typeof e=="string"?(o=e,e=0):e>2147483647?e=2147483647:e<-2147483648&&(e=-2147483648),e=+e,Ct(e)&&(e=l?0:i.length-1),e<0&&(e=i.length+e),e>=i.length){if(l)return-1;e=i.length-1}else if(e<0)if(l)e=0;else return-1;if(typeof t=="string"&&(t=a.from(t,o)),a.isBuffer(t))return t.length===0?-1:Ht(i,t,e,o,l);if(typeof t=="number")return t=t&255,typeof Uint8Array.prototype.indexOf=="function"?l?Uint8Array.prototype.indexOf.call(i,t,e):Uint8Array.prototype.lastIndexOf.call(i,t,e):Ht(i,[t],e,o,l);throw new TypeError("val must be string, number or Buffer")}function Ht(i,t,e,o,l){let f=1,p=i.length,S=t.length;if(o!==void 0&&(o=String(o).toLowerCase(),o==="ucs2"||o==="ucs-2"||o==="utf16le"||o==="utf-16le")){if(i.length<2||t.length<2)return-1;f=2,p/=2,S/=2,e/=2}function K(M,L){return f===1?M[L]:M.readUInt16BE(L*f)}let N;if(l){let M=-1;for(N=e;N<p;N++)if(K(i,N)===K(t,M===-1?0:N-M)){if(M===-1&&(M=N),N-M+1===S)return M*f}else M!==-1&&(N-=N-M),M=-1}else for(e+S>p&&(e=p-S),N=e;N>=0;N--){let M=!0;for(let L=0;L<S;L++)if(K(i,N+L)!==K(t,L)){M=!1;break}if(M)return N}return-1}a.prototype.includes=function(t,e,o){return this.indexOf(t,e,o)!==-1},a.prototype.indexOf=function(t,e,o){return Gt(this,t,e,o,!0)},a.prototype.lastIndexOf=function(t,e,o){return Gt(this,t,e,o,!1)};function Ee(i,t,e,o){e=Number(e)||0;const l=i.length-e;o?(o=Number(o),o>l&&(o=l)):o=l;const f=t.length;o>f/2&&(o=f/2);let p;for(p=0;p<o;++p){const S=parseInt(t.substr(p*2,2),16);if(Ct(S))return p;i[e+p]=S}return p}function Ie(i,t,e,o){return St(Tt(t,i.length-e),i,e,o)}function Se(i,t,e,o){return St(Ne(t),i,e,o)}function xe(i,t,e,o){return St(ne(t),i,e,o)}function ke(i,t,e,o){return St(De(t,i.length-e),i,e,o)}a.prototype.write=function(t,e,o,l){if(e===void 0)l="utf8",o=this.length,e=0;else if(o===void 0&&typeof e=="string")l=e,o=this.length,e=0;else if(isFinite(e))e=e>>>0,isFinite(o)?(o=o>>>0,l===void 0&&(l="utf8")):(l=o,o=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const f=this.length-e;if((o===void 0||o>f)&&(o=f),t.length>0&&(o<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");l||(l="utf8");let p=!1;for(;;)switch(l){case"hex":return Ee(this,t,e,o);case"utf8":case"utf-8":return Ie(this,t,e,o);case"ascii":case"latin1":case"binary":return Se(this,t,e,o);case"base64":return xe(this,t,e,o);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ke(this,t,e,o);default:if(p)throw new TypeError("Unknown encoding: "+l);l=(""+l).toLowerCase(),p=!0}},a.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function Ae(i,t,e){return t===0&&e===i.length?n.fromByteArray(i):n.fromByteArray(i.slice(t,e))}function Vt(i,t,e){e=Math.min(i.length,e);const o=[];let l=t;for(;l<e;){const f=i[l];let p=null,S=f>239?4:f>223?3:f>191?2:1;if(l+S<=e){let K,N,M,L;switch(S){case 1:f<128&&(p=f);break;case 2:K=i[l+1],(K&192)===128&&(L=(f&31)<<6|K&63,L>127&&(p=L));break;case 3:K=i[l+1],N=i[l+2],(K&192)===128&&(N&192)===128&&(L=(f&15)<<12|(K&63)<<6|N&63,L>2047&&(L<55296||L>57343)&&(p=L));break;case 4:K=i[l+1],N=i[l+2],M=i[l+3],(K&192)===128&&(N&192)===128&&(M&192)===128&&(L=(f&15)<<18|(K&63)<<12|(N&63)<<6|M&63,L>65535&&L<1114112&&(p=L))}}p===null?(p=65533,S=1):p>65535&&(p-=65536,o.push(p>>>10&1023|55296),p=56320|p&1023),o.push(p),l+=S}return Re(o)}const jt=4096;function Re(i){const t=i.length;if(t<=jt)return String.fromCharCode.apply(String,i);let e="",o=0;for(;o<t;)e+=String.fromCharCode.apply(String,i.slice(o,o+=jt));return e}function _e(i,t,e){let o="";e=Math.min(i.length,e);for(let l=t;l<e;++l)o+=String.fromCharCode(i[l]&127);return o}function Te(i,t,e){let o="";e=Math.min(i.length,e);for(let l=t;l<e;++l)o+=String.fromCharCode(i[l]);return o}function Ce(i,t,e){const o=i.length;(!t||t<0)&&(t=0),(!e||e<0||e>o)&&(e=o);let l="";for(let f=t;f<e;++f)l+=Oe[i[f]];return l}function Ue(i,t,e){const o=i.slice(t,e);let l="";for(let f=0;f<o.length-1;f+=2)l+=String.fromCharCode(o[f]+o[f+1]*256);return l}a.prototype.slice=function(t,e){const o=this.length;t=~~t,e=e===void 0?o:~~e,t<0?(t+=o,t<0&&(t=0)):t>o&&(t=o),e<0?(e+=o,e<0&&(e=0)):e>o&&(e=o),e<t&&(e=t);const l=this.subarray(t,e);return Object.setPrototypeOf(l,a.prototype),l};function v(i,t,e){if(i%1!==0||i<0)throw new RangeError("offset is not uint");if(i+t>e)throw new RangeError("Trying to access beyond buffer length")}a.prototype.readUintLE=a.prototype.readUIntLE=function(t,e,o){t=t>>>0,e=e>>>0,o||v(t,e,this.length);let l=this[t],f=1,p=0;for(;++p<e&&(f*=256);)l+=this[t+p]*f;return l},a.prototype.readUintBE=a.prototype.readUIntBE=function(t,e,o){t=t>>>0,e=e>>>0,o||v(t,e,this.length);let l=this[t+--e],f=1;for(;e>0&&(f*=256);)l+=this[t+--e]*f;return l},a.prototype.readUint8=a.prototype.readUInt8=function(t,e){return t=t>>>0,e||v(t,1,this.length),this[t]},a.prototype.readUint16LE=a.prototype.readUInt16LE=function(t,e){return t=t>>>0,e||v(t,2,this.length),this[t]|this[t+1]<<8},a.prototype.readUint16BE=a.prototype.readUInt16BE=function(t,e){return t=t>>>0,e||v(t,2,this.length),this[t]<<8|this[t+1]},a.prototype.readUint32LE=a.prototype.readUInt32LE=function(t,e){return t=t>>>0,e||v(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+this[t+3]*16777216},a.prototype.readUint32BE=a.prototype.readUInt32BE=function(t,e){return t=t>>>0,e||v(t,4,this.length),this[t]*16777216+(this[t+1]<<16|this[t+2]<<8|this[t+3])},a.prototype.readBigUInt64LE=it(function(t){t=t>>>0,dt(t,"offset");const e=this[t],o=this[t+7];(e===void 0||o===void 0)&&bt(t,this.length-8);const l=e+this[++t]*2**8+this[++t]*2**16+this[++t]*2**24,f=this[++t]+this[++t]*2**8+this[++t]*2**16+o*2**24;return BigInt(l)+(BigInt(f)<<BigInt(32))}),a.prototype.readBigUInt64BE=it(function(t){t=t>>>0,dt(t,"offset");const e=this[t],o=this[t+7];(e===void 0||o===void 0)&&bt(t,this.length-8);const l=e*2**24+this[++t]*2**16+this[++t]*2**8+this[++t],f=this[++t]*2**24+this[++t]*2**16+this[++t]*2**8+o;return(BigInt(l)<<BigInt(32))+BigInt(f)}),a.prototype.readIntLE=function(t,e,o){t=t>>>0,e=e>>>0,o||v(t,e,this.length);let l=this[t],f=1,p=0;for(;++p<e&&(f*=256);)l+=this[t+p]*f;return f*=128,l>=f&&(l-=Math.pow(2,8*e)),l},a.prototype.readIntBE=function(t,e,o){t=t>>>0,e=e>>>0,o||v(t,e,this.length);let l=e,f=1,p=this[t+--l];for(;l>0&&(f*=256);)p+=this[t+--l]*f;return f*=128,p>=f&&(p-=Math.pow(2,8*e)),p},a.prototype.readInt8=function(t,e){return t=t>>>0,e||v(t,1,this.length),this[t]&128?(255-this[t]+1)*-1:this[t]},a.prototype.readInt16LE=function(t,e){t=t>>>0,e||v(t,2,this.length);const o=this[t]|this[t+1]<<8;return o&32768?o|4294901760:o},a.prototype.readInt16BE=function(t,e){t=t>>>0,e||v(t,2,this.length);const o=this[t+1]|this[t]<<8;return o&32768?o|4294901760:o},a.prototype.readInt32LE=function(t,e){return t=t>>>0,e||v(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},a.prototype.readInt32BE=function(t,e){return t=t>>>0,e||v(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},a.prototype.readBigInt64LE=it(function(t){t=t>>>0,dt(t,"offset");const e=this[t],o=this[t+7];(e===void 0||o===void 0)&&bt(t,this.length-8);const l=this[t+4]+this[t+5]*2**8+this[t+6]*2**16+(o<<24);return(BigInt(l)<<BigInt(32))+BigInt(e+this[++t]*2**8+this[++t]*2**16+this[++t]*2**24)}),a.prototype.readBigInt64BE=it(function(t){t=t>>>0,dt(t,"offset");const e=this[t],o=this[t+7];(e===void 0||o===void 0)&&bt(t,this.length-8);const l=(e<<24)+this[++t]*2**16+this[++t]*2**8+this[++t];return(BigInt(l)<<BigInt(32))+BigInt(this[++t]*2**24+this[++t]*2**16+this[++t]*2**8+o)}),a.prototype.readFloatLE=function(t,e){return t=t>>>0,e||v(t,4,this.length),r.read(this,t,!0,23,4)},a.prototype.readFloatBE=function(t,e){return t=t>>>0,e||v(t,4,this.length),r.read(this,t,!1,23,4)},a.prototype.readDoubleLE=function(t,e){return t=t>>>0,e||v(t,8,this.length),r.read(this,t,!0,52,8)},a.prototype.readDoubleBE=function(t,e){return t=t>>>0,e||v(t,8,this.length),r.read(this,t,!1,52,8)};function j(i,t,e,o,l,f){if(!a.isBuffer(i))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>l||t<f)throw new RangeError('"value" argument is out of bounds');if(e+o>i.length)throw new RangeError("Index out of range")}a.prototype.writeUintLE=a.prototype.writeUIntLE=function(t,e,o,l){if(t=+t,e=e>>>0,o=o>>>0,!l){const S=Math.pow(2,8*o)-1;j(this,t,e,o,S,0)}let f=1,p=0;for(this[e]=t&255;++p<o&&(f*=256);)this[e+p]=t/f&255;return e+o},a.prototype.writeUintBE=a.prototype.writeUIntBE=function(t,e,o,l){if(t=+t,e=e>>>0,o=o>>>0,!l){const S=Math.pow(2,8*o)-1;j(this,t,e,o,S,0)}let f=o-1,p=1;for(this[e+f]=t&255;--f>=0&&(p*=256);)this[e+f]=t/p&255;return e+o},a.prototype.writeUint8=a.prototype.writeUInt8=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,1,255,0),this[e]=t&255,e+1},a.prototype.writeUint16LE=a.prototype.writeUInt16LE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,2,65535,0),this[e]=t&255,this[e+1]=t>>>8,e+2},a.prototype.writeUint16BE=a.prototype.writeUInt16BE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=t&255,e+2},a.prototype.writeUint32LE=a.prototype.writeUInt32LE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=t&255,e+4},a.prototype.writeUint32BE=a.prototype.writeUInt32BE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=t&255,e+4};function Jt(i,t,e,o,l){ee(t,o,l,i,e,7);let f=Number(t&BigInt(4294967295));i[e++]=f,f=f>>8,i[e++]=f,f=f>>8,i[e++]=f,f=f>>8,i[e++]=f;let p=Number(t>>BigInt(32)&BigInt(4294967295));return i[e++]=p,p=p>>8,i[e++]=p,p=p>>8,i[e++]=p,p=p>>8,i[e++]=p,e}function Yt(i,t,e,o,l){ee(t,o,l,i,e,7);let f=Number(t&BigInt(4294967295));i[e+7]=f,f=f>>8,i[e+6]=f,f=f>>8,i[e+5]=f,f=f>>8,i[e+4]=f;let p=Number(t>>BigInt(32)&BigInt(4294967295));return i[e+3]=p,p=p>>8,i[e+2]=p,p=p>>8,i[e+1]=p,p=p>>8,i[e]=p,e+8}a.prototype.writeBigUInt64LE=it(function(t,e=0){return Jt(this,t,e,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeBigUInt64BE=it(function(t,e=0){return Yt(this,t,e,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeIntLE=function(t,e,o,l){if(t=+t,e=e>>>0,!l){const K=Math.pow(2,8*o-1);j(this,t,e,o,K-1,-K)}let f=0,p=1,S=0;for(this[e]=t&255;++f<o&&(p*=256);)t<0&&S===0&&this[e+f-1]!==0&&(S=1),this[e+f]=(t/p>>0)-S&255;return e+o},a.prototype.writeIntBE=function(t,e,o,l){if(t=+t,e=e>>>0,!l){const K=Math.pow(2,8*o-1);j(this,t,e,o,K-1,-K)}let f=o-1,p=1,S=0;for(this[e+f]=t&255;--f>=0&&(p*=256);)t<0&&S===0&&this[e+f+1]!==0&&(S=1),this[e+f]=(t/p>>0)-S&255;return e+o},a.prototype.writeInt8=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=t&255,e+1},a.prototype.writeInt16LE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,2,32767,-32768),this[e]=t&255,this[e+1]=t>>>8,e+2},a.prototype.writeInt16BE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=t&255,e+2},a.prototype.writeInt32LE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,4,2147483647,-2147483648),this[e]=t&255,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},a.prototype.writeInt32BE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=t&255,e+4},a.prototype.writeBigInt64LE=it(function(t,e=0){return Jt(this,t,e,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),a.prototype.writeBigInt64BE=it(function(t,e=0){return Yt(this,t,e,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Xt(i,t,e,o,l,f){if(e+o>i.length)throw new RangeError("Index out of range");if(e<0)throw new RangeError("Index out of range")}function Zt(i,t,e,o,l){return t=+t,e=e>>>0,l||Xt(i,t,e,4),r.write(i,t,e,o,23,4),e+4}a.prototype.writeFloatLE=function(t,e,o){return Zt(this,t,e,!0,o)},a.prototype.writeFloatBE=function(t,e,o){return Zt(this,t,e,!1,o)};function Qt(i,t,e,o,l){return t=+t,e=e>>>0,l||Xt(i,t,e,8),r.write(i,t,e,o,52,8),e+8}a.prototype.writeDoubleLE=function(t,e,o){return Qt(this,t,e,!0,o)},a.prototype.writeDoubleBE=function(t,e,o){return Qt(this,t,e,!1,o)},a.prototype.copy=function(t,e,o,l){if(!a.isBuffer(t))throw new TypeError("argument should be a Buffer");if(o||(o=0),!l&&l!==0&&(l=this.length),e>=t.length&&(e=t.length),e||(e=0),l>0&&l<o&&(l=o),l===o||t.length===0||this.length===0)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(o<0||o>=this.length)throw new RangeError("Index out of range");if(l<0)throw new RangeError("sourceEnd out of bounds");l>this.length&&(l=this.length),t.length-e<l-o&&(l=t.length-e+o);const f=l-o;return this===t&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(e,o,l):Uint8Array.prototype.set.call(t,this.subarray(o,l),e),f},a.prototype.fill=function(t,e,o,l){if(typeof t=="string"){if(typeof e=="string"?(l=e,e=0,o=this.length):typeof o=="string"&&(l=o,o=this.length),l!==void 0&&typeof l!="string")throw new TypeError("encoding must be a string");if(typeof l=="string"&&!a.isEncoding(l))throw new TypeError("Unknown encoding: "+l);if(t.length===1){const p=t.charCodeAt(0);(l==="utf8"&&p<128||l==="latin1")&&(t=p)}}else typeof t=="number"?t=t&255:typeof t=="boolean"&&(t=Number(t));if(e<0||this.length<e||this.length<o)throw new RangeError("Out of range index");if(o<=e)return this;e=e>>>0,o=o===void 0?this.length:o>>>0,t||(t=0);let f;if(typeof t=="number")for(f=e;f<o;++f)this[f]=t;else{const p=a.isBuffer(t)?t:a.from(t,l),S=p.length;if(S===0)throw new TypeError('The value "'+t+'" is invalid for argument "value"');for(f=0;f<o-e;++f)this[f+e]=p[f%S]}return this};const ht={};function _t(i,t,e){ht[i]=class extends e{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${i}]`,this.stack,delete this.name}get code(){return i}set code(l){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:l,writable:!0})}toString(){return`${this.name} [${i}]: ${this.message}`}}}_t("ERR_BUFFER_OUT_OF_BOUNDS",function(i){return i?`${i} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),_t("ERR_INVALID_ARG_TYPE",function(i,t){return`The "${i}" argument must be of type number. Received type ${typeof t}`},TypeError),_t("ERR_OUT_OF_RANGE",function(i,t,e){let o=`The value of "${i}" is out of range.`,l=e;return Number.isInteger(e)&&Math.abs(e)>2**32?l=te(String(e)):typeof e=="bigint"&&(l=String(e),(e>BigInt(2)**BigInt(32)||e<-(BigInt(2)**BigInt(32)))&&(l=te(l)),l+="n"),o+=` It must be ${t}. Received ${l}`,o},RangeError);function te(i){let t="",e=i.length;const o=i[0]==="-"?1:0;for(;e>=o+4;e-=3)t=`_${i.slice(e-3,e)}${t}`;return`${i.slice(0,e)}${t}`}function Le(i,t,e){dt(t,"offset"),(i[t]===void 0||i[t+e]===void 0)&&bt(t,i.length-(e+1))}function ee(i,t,e,o,l,f){if(i>e||i<t){const p=typeof t=="bigint"?"n":"";let S;throw f>3?t===0||t===BigInt(0)?S=`>= 0${p} and < 2${p} ** ${(f+1)*8}${p}`:S=`>= -(2${p} ** ${(f+1)*8-1}${p}) and < 2 ** ${(f+1)*8-1}${p}`:S=`>= ${t}${p} and <= ${e}${p}`,new ht.ERR_OUT_OF_RANGE("value",S,i)}Le(o,l,f)}function dt(i,t){if(typeof i!="number")throw new ht.ERR_INVALID_ARG_TYPE(t,"number",i)}function bt(i,t,e){throw Math.floor(i)!==i?(dt(i,e),new ht.ERR_OUT_OF_RANGE(e||"offset","an integer",i)):t<0?new ht.ERR_BUFFER_OUT_OF_BOUNDS:new ht.ERR_OUT_OF_RANGE(e||"offset",`>= ${e?1:0} and <= ${t}`,i)}const Fe=/[^+/0-9A-Za-z-_]/g;function Pe(i){if(i=i.split("=")[0],i=i.trim().replace(Fe,""),i.length<2)return"";for(;i.length%4!==0;)i=i+"=";return i}function Tt(i,t){t=t||1/0;let e;const o=i.length;let l=null;const f=[];for(let p=0;p<o;++p){if(e=i.charCodeAt(p),e>55295&&e<57344){if(!l){if(e>56319){(t-=3)>-1&&f.push(239,191,189);continue}else if(p+1===o){(t-=3)>-1&&f.push(239,191,189);continue}l=e;continue}if(e<56320){(t-=3)>-1&&f.push(239,191,189),l=e;continue}e=(l-55296<<10|e-56320)+65536}else l&&(t-=3)>-1&&f.push(239,191,189);if(l=null,e<128){if((t-=1)<0)break;f.push(e)}else if(e<2048){if((t-=2)<0)break;f.push(e>>6|192,e&63|128)}else if(e<65536){if((t-=3)<0)break;f.push(e>>12|224,e>>6&63|128,e&63|128)}else if(e<1114112){if((t-=4)<0)break;f.push(e>>18|240,e>>12&63|128,e>>6&63|128,e&63|128)}else throw new Error("Invalid code point")}return f}function Ne(i){const t=[];for(let e=0;e<i.length;++e)t.push(i.charCodeAt(e)&255);return t}function De(i,t){let e,o,l;const f=[];for(let p=0;p<i.length&&!((t-=2)<0);++p)e=i.charCodeAt(p),o=e>>8,l=e%256,f.push(l),f.push(o);return f}function ne(i){return n.toByteArray(Pe(i))}function St(i,t,e,o){let l;for(l=0;l<o&&!(l+e>=t.length||l>=i.length);++l)t[l+e]=i[l];return l}function tt(i,t){return i instanceof t||i!=null&&i.constructor!=null&&i.constructor.name!=null&&i.constructor.name===t.name}function Ct(i){return i!==i}const Oe=function(){const i="0123456789abcdef",t=new Array(256);for(let e=0;e<16;++e){const o=e*16;for(let l=0;l<16;++l)t[o+l]=i[e]+i[l]}return t}();function it(i){return typeof BigInt>"u"?Ke:i}function Ke(){throw new Error("BigInt not supported")}})($);var m={},Rn={};/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */(function(d){const n=Sn,r=xn,s=typeof Symbol=="function"&&typeof Symbol.for=="function"?Symbol.for("nodejs.util.inspect.custom"):null;d.Buffer=a,d.SlowBuffer=rt,d.INSPECT_MAX_BYTES=50;const c=2147483647;d.kMaxLength=c,a.TYPED_ARRAY_SUPPORT=u(),!a.TYPED_ARRAY_SUPPORT&&typeof console<"u"&&typeof console.error=="function"&&console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");function u(){try{const i=new Uint8Array(1),t={foo:function(){return 42}};return Object.setPrototypeOf(t,Uint8Array.prototype),Object.setPrototypeOf(i,t),i.foo()===42}catch{return!1}}Object.defineProperty(a.prototype,"parent",{enumerable:!0,get:function(){if(a.isBuffer(this))return this.buffer}}),Object.defineProperty(a.prototype,"offset",{enumerable:!0,get:function(){if(a.isBuffer(this))return this.byteOffset}});function h(i){if(i>c)throw new RangeError('The value "'+i+'" is invalid for option "size"');const t=new Uint8Array(i);return Object.setPrototypeOf(t,a.prototype),t}function a(i,t,e){if(typeof i=="number"){if(typeof t=="string")throw new TypeError('The "string" argument must be of type string. Received type number');return U(i)}return g(i,t,e)}a.poolSize=8192;function g(i,t,e){if(typeof i=="string")return q(i,t);if(ArrayBuffer.isView(i))return A(i);if(i==null)throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof i);if(tt(i,ArrayBuffer)||i&&tt(i.buffer,ArrayBuffer)||typeof SharedArrayBuffer<"u"&&(tt(i,SharedArrayBuffer)||i&&tt(i.buffer,SharedArrayBuffer)))return b(i,t,e);if(typeof i=="number")throw new TypeError('The "value" argument must not be of type number. Received type number');const o=i.valueOf&&i.valueOf();if(o!=null&&o!==i)return a.from(o,t,e);const l=_(i);if(l)return l;if(typeof Symbol<"u"&&Symbol.toPrimitive!=null&&typeof i[Symbol.toPrimitive]=="function")return a.from(i[Symbol.toPrimitive]("string"),t,e);throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type "+typeof i)}a.from=function(i,t,e){return g(i,t,e)},Object.setPrototypeOf(a.prototype,Uint8Array.prototype),Object.setPrototypeOf(a,Uint8Array);function E(i){if(typeof i!="number")throw new TypeError('"size" argument must be of type number');if(i<0)throw new RangeError('The value "'+i+'" is invalid for option "size"')}function F(i,t,e){return E(i),i<=0?h(i):t!==void 0?typeof e=="string"?h(i).fill(t,e):h(i).fill(t):h(i)}a.alloc=function(i,t,e){return F(i,t,e)};function U(i){return E(i),h(i<0?0:z(i)|0)}a.allocUnsafe=function(i){return U(i)},a.allocUnsafeSlow=function(i){return U(i)};function q(i,t){if((typeof t!="string"||t==="")&&(t="utf8"),!a.isEncoding(t))throw new TypeError("Unknown encoding: "+t);const e=wt(i,t)|0;let o=h(e);const l=o.write(i,t);return l!==e&&(o=o.slice(0,l)),o}function R(i){const t=i.length<0?0:z(i.length)|0,e=h(t);for(let o=0;o<t;o+=1)e[o]=i[o]&255;return e}function A(i){if(tt(i,Uint8Array)){const t=new Uint8Array(i);return b(t.buffer,t.byteOffset,t.byteLength)}return R(i)}function b(i,t,e){if(t<0||i.byteLength<t)throw new RangeError('"offset" is outside of buffer bounds');if(i.byteLength<t+(e||0))throw new RangeError('"length" is outside of buffer bounds');let o;return t===void 0&&e===void 0?o=new Uint8Array(i):e===void 0?o=new Uint8Array(i,t):o=new Uint8Array(i,t,e),Object.setPrototypeOf(o,a.prototype),o}function _(i){if(a.isBuffer(i)){const t=z(i.length)|0,e=h(t);return e.length===0||i.copy(e,0,0,t),e}if(i.length!==void 0)return typeof i.length!="number"||Ct(i.length)?h(0):R(i);if(i.type==="Buffer"&&Array.isArray(i.data))return R(i.data)}function z(i){if(i>=c)throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+c.toString(16)+" bytes");return i|0}function rt(i){return+i!=i&&(i=0),a.alloc(+i)}a.isBuffer=function(t){return t!=null&&t._isBuffer===!0&&t!==a.prototype},a.compare=function(t,e){if(tt(t,Uint8Array)&&(t=a.from(t,t.offset,t.byteLength)),tt(e,Uint8Array)&&(e=a.from(e,e.offset,e.byteLength)),!a.isBuffer(t)||!a.isBuffer(e))throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');if(t===e)return 0;let o=t.length,l=e.length;for(let f=0,p=Math.min(o,l);f<p;++f)if(t[f]!==e[f]){o=t[f],l=e[f];break}return o<l?-1:l<o?1:0},a.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},a.concat=function(t,e){if(!Array.isArray(t))throw new TypeError('"list" argument must be an Array of Buffers');if(t.length===0)return a.alloc(0);let o;if(e===void 0)for(e=0,o=0;o<t.length;++o)e+=t[o].length;const l=a.allocUnsafe(e);let f=0;for(o=0;o<t.length;++o){let p=t[o];if(tt(p,Uint8Array))f+p.length>l.length?(a.isBuffer(p)||(p=a.from(p)),p.copy(l,f)):Uint8Array.prototype.set.call(l,p,f);else if(a.isBuffer(p))p.copy(l,f);else throw new TypeError('"list" argument must be an Array of Buffers');f+=p.length}return l};function wt(i,t){if(a.isBuffer(i))return i.length;if(ArrayBuffer.isView(i)||tt(i,ArrayBuffer))return i.byteLength;if(typeof i!="string")throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof i);const e=i.length,o=arguments.length>2&&arguments[2]===!0;if(!o&&e===0)return 0;let l=!1;for(;;)switch(t){case"ascii":case"latin1":case"binary":return e;case"utf8":case"utf-8":return Tt(i).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return e*2;case"hex":return e>>>1;case"base64":return ne(i).length;default:if(l)return o?-1:Tt(i).length;t=(""+t).toLowerCase(),l=!0}}a.byteLength=wt;function Rt(i,t,e){let o=!1;if((t===void 0||t<0)&&(t=0),t>this.length||((e===void 0||e>this.length)&&(e=this.length),e<=0)||(e>>>=0,t>>>=0,e<=t))return"";for(i||(i="utf8");;)switch(i){case"hex":return Ce(this,t,e);case"utf8":case"utf-8":return Vt(this,t,e);case"ascii":return _e(this,t,e);case"latin1":case"binary":return Te(this,t,e);case"base64":return Ae(this,t,e);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return Ue(this,t,e);default:if(o)throw new TypeError("Unknown encoding: "+i);i=(i+"").toLowerCase(),o=!0}}a.prototype._isBuffer=!0;function ct(i,t,e){const o=i[t];i[t]=i[e],i[e]=o}a.prototype.swap16=function(){const t=this.length;if(t%2!==0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(let e=0;e<t;e+=2)ct(this,e,e+1);return this},a.prototype.swap32=function(){const t=this.length;if(t%4!==0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(let e=0;e<t;e+=4)ct(this,e,e+3),ct(this,e+1,e+2);return this},a.prototype.swap64=function(){const t=this.length;if(t%8!==0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(let e=0;e<t;e+=8)ct(this,e,e+7),ct(this,e+1,e+6),ct(this,e+2,e+5),ct(this,e+3,e+4);return this},a.prototype.toString=function(){const t=this.length;return t===0?"":arguments.length===0?Vt(this,0,t):Rt.apply(this,arguments)},a.prototype.toLocaleString=a.prototype.toString,a.prototype.equals=function(t){if(!a.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t?!0:a.compare(this,t)===0},a.prototype.inspect=function(){let t="";const e=d.INSPECT_MAX_BYTES;return t=this.toString("hex",0,e).replace(/(.{2})/g,"$1 ").trim(),this.length>e&&(t+=" ... "),"<Buffer "+t+">"},s&&(a.prototype[s]=a.prototype.inspect),a.prototype.compare=function(t,e,o,l,f){if(tt(t,Uint8Array)&&(t=a.from(t,t.offset,t.byteLength)),!a.isBuffer(t))throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type '+typeof t);if(e===void 0&&(e=0),o===void 0&&(o=t?t.length:0),l===void 0&&(l=0),f===void 0&&(f=this.length),e<0||o>t.length||l<0||f>this.length)throw new RangeError("out of range index");if(l>=f&&e>=o)return 0;if(l>=f)return-1;if(e>=o)return 1;if(e>>>=0,o>>>=0,l>>>=0,f>>>=0,this===t)return 0;let p=f-l,S=o-e;const K=Math.min(p,S),N=this.slice(l,f),M=t.slice(e,o);for(let L=0;L<K;++L)if(N[L]!==M[L]){p=N[L],S=M[L];break}return p<S?-1:S<p?1:0};function Gt(i,t,e,o,l){if(i.length===0)return-1;if(typeof e=="string"?(o=e,e=0):e>2147483647?e=2147483647:e<-2147483648&&(e=-2147483648),e=+e,Ct(e)&&(e=l?0:i.length-1),e<0&&(e=i.length+e),e>=i.length){if(l)return-1;e=i.length-1}else if(e<0)if(l)e=0;else return-1;if(typeof t=="string"&&(t=a.from(t,o)),a.isBuffer(t))return t.length===0?-1:Ht(i,t,e,o,l);if(typeof t=="number")return t=t&255,typeof Uint8Array.prototype.indexOf=="function"?l?Uint8Array.prototype.indexOf.call(i,t,e):Uint8Array.prototype.lastIndexOf.call(i,t,e):Ht(i,[t],e,o,l);throw new TypeError("val must be string, number or Buffer")}function Ht(i,t,e,o,l){let f=1,p=i.length,S=t.length;if(o!==void 0&&(o=String(o).toLowerCase(),o==="ucs2"||o==="ucs-2"||o==="utf16le"||o==="utf-16le")){if(i.length<2||t.length<2)return-1;f=2,p/=2,S/=2,e/=2}function K(M,L){return f===1?M[L]:M.readUInt16BE(L*f)}let N;if(l){let M=-1;for(N=e;N<p;N++)if(K(i,N)===K(t,M===-1?0:N-M)){if(M===-1&&(M=N),N-M+1===S)return M*f}else M!==-1&&(N-=N-M),M=-1}else for(e+S>p&&(e=p-S),N=e;N>=0;N--){let M=!0;for(let L=0;L<S;L++)if(K(i,N+L)!==K(t,L)){M=!1;break}if(M)return N}return-1}a.prototype.includes=function(t,e,o){return this.indexOf(t,e,o)!==-1},a.prototype.indexOf=function(t,e,o){return Gt(this,t,e,o,!0)},a.prototype.lastIndexOf=function(t,e,o){return Gt(this,t,e,o,!1)};function Ee(i,t,e,o){e=Number(e)||0;const l=i.length-e;o?(o=Number(o),o>l&&(o=l)):o=l;const f=t.length;o>f/2&&(o=f/2);let p;for(p=0;p<o;++p){const S=parseInt(t.substr(p*2,2),16);if(Ct(S))return p;i[e+p]=S}return p}function Ie(i,t,e,o){return St(Tt(t,i.length-e),i,e,o)}function Se(i,t,e,o){return St(Ne(t),i,e,o)}function xe(i,t,e,o){return St(ne(t),i,e,o)}function ke(i,t,e,o){return St(De(t,i.length-e),i,e,o)}a.prototype.write=function(t,e,o,l){if(e===void 0)l="utf8",o=this.length,e=0;else if(o===void 0&&typeof e=="string")l=e,o=this.length,e=0;else if(isFinite(e))e=e>>>0,isFinite(o)?(o=o>>>0,l===void 0&&(l="utf8")):(l=o,o=void 0);else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");const f=this.length-e;if((o===void 0||o>f)&&(o=f),t.length>0&&(o<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");l||(l="utf8");let p=!1;for(;;)switch(l){case"hex":return Ee(this,t,e,o);case"utf8":case"utf-8":return Ie(this,t,e,o);case"ascii":case"latin1":case"binary":return Se(this,t,e,o);case"base64":return xe(this,t,e,o);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ke(this,t,e,o);default:if(p)throw new TypeError("Unknown encoding: "+l);l=(""+l).toLowerCase(),p=!0}},a.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function Ae(i,t,e){return t===0&&e===i.length?n.fromByteArray(i):n.fromByteArray(i.slice(t,e))}function Vt(i,t,e){e=Math.min(i.length,e);const o=[];let l=t;for(;l<e;){const f=i[l];let p=null,S=f>239?4:f>223?3:f>191?2:1;if(l+S<=e){let K,N,M,L;switch(S){case 1:f<128&&(p=f);break;case 2:K=i[l+1],(K&192)===128&&(L=(f&31)<<6|K&63,L>127&&(p=L));break;case 3:K=i[l+1],N=i[l+2],(K&192)===128&&(N&192)===128&&(L=(f&15)<<12|(K&63)<<6|N&63,L>2047&&(L<55296||L>57343)&&(p=L));break;case 4:K=i[l+1],N=i[l+2],M=i[l+3],(K&192)===128&&(N&192)===128&&(M&192)===128&&(L=(f&15)<<18|(K&63)<<12|(N&63)<<6|M&63,L>65535&&L<1114112&&(p=L))}}p===null?(p=65533,S=1):p>65535&&(p-=65536,o.push(p>>>10&1023|55296),p=56320|p&1023),o.push(p),l+=S}return Re(o)}const jt=4096;function Re(i){const t=i.length;if(t<=jt)return String.fromCharCode.apply(String,i);let e="",o=0;for(;o<t;)e+=String.fromCharCode.apply(String,i.slice(o,o+=jt));return e}function _e(i,t,e){let o="";e=Math.min(i.length,e);for(let l=t;l<e;++l)o+=String.fromCharCode(i[l]&127);return o}function Te(i,t,e){let o="";e=Math.min(i.length,e);for(let l=t;l<e;++l)o+=String.fromCharCode(i[l]);return o}function Ce(i,t,e){const o=i.length;(!t||t<0)&&(t=0),(!e||e<0||e>o)&&(e=o);let l="";for(let f=t;f<e;++f)l+=Oe[i[f]];return l}function Ue(i,t,e){const o=i.slice(t,e);let l="";for(let f=0;f<o.length-1;f+=2)l+=String.fromCharCode(o[f]+o[f+1]*256);return l}a.prototype.slice=function(t,e){const o=this.length;t=~~t,e=e===void 0?o:~~e,t<0?(t+=o,t<0&&(t=0)):t>o&&(t=o),e<0?(e+=o,e<0&&(e=0)):e>o&&(e=o),e<t&&(e=t);const l=this.subarray(t,e);return Object.setPrototypeOf(l,a.prototype),l};function v(i,t,e){if(i%1!==0||i<0)throw new RangeError("offset is not uint");if(i+t>e)throw new RangeError("Trying to access beyond buffer length")}a.prototype.readUintLE=a.prototype.readUIntLE=function(t,e,o){t=t>>>0,e=e>>>0,o||v(t,e,this.length);let l=this[t],f=1,p=0;for(;++p<e&&(f*=256);)l+=this[t+p]*f;return l},a.prototype.readUintBE=a.prototype.readUIntBE=function(t,e,o){t=t>>>0,e=e>>>0,o||v(t,e,this.length);let l=this[t+--e],f=1;for(;e>0&&(f*=256);)l+=this[t+--e]*f;return l},a.prototype.readUint8=a.prototype.readUInt8=function(t,e){return t=t>>>0,e||v(t,1,this.length),this[t]},a.prototype.readUint16LE=a.prototype.readUInt16LE=function(t,e){return t=t>>>0,e||v(t,2,this.length),this[t]|this[t+1]<<8},a.prototype.readUint16BE=a.prototype.readUInt16BE=function(t,e){return t=t>>>0,e||v(t,2,this.length),this[t]<<8|this[t+1]},a.prototype.readUint32LE=a.prototype.readUInt32LE=function(t,e){return t=t>>>0,e||v(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+this[t+3]*16777216},a.prototype.readUint32BE=a.prototype.readUInt32BE=function(t,e){return t=t>>>0,e||v(t,4,this.length),this[t]*16777216+(this[t+1]<<16|this[t+2]<<8|this[t+3])},a.prototype.readBigUInt64LE=it(function(t){t=t>>>0,dt(t,"offset");const e=this[t],o=this[t+7];(e===void 0||o===void 0)&&bt(t,this.length-8);const l=e+this[++t]*2**8+this[++t]*2**16+this[++t]*2**24,f=this[++t]+this[++t]*2**8+this[++t]*2**16+o*2**24;return BigInt(l)+(BigInt(f)<<BigInt(32))}),a.prototype.readBigUInt64BE=it(function(t){t=t>>>0,dt(t,"offset");const e=this[t],o=this[t+7];(e===void 0||o===void 0)&&bt(t,this.length-8);const l=e*2**24+this[++t]*2**16+this[++t]*2**8+this[++t],f=this[++t]*2**24+this[++t]*2**16+this[++t]*2**8+o;return(BigInt(l)<<BigInt(32))+BigInt(f)}),a.prototype.readIntLE=function(t,e,o){t=t>>>0,e=e>>>0,o||v(t,e,this.length);let l=this[t],f=1,p=0;for(;++p<e&&(f*=256);)l+=this[t+p]*f;return f*=128,l>=f&&(l-=Math.pow(2,8*e)),l},a.prototype.readIntBE=function(t,e,o){t=t>>>0,e=e>>>0,o||v(t,e,this.length);let l=e,f=1,p=this[t+--l];for(;l>0&&(f*=256);)p+=this[t+--l]*f;return f*=128,p>=f&&(p-=Math.pow(2,8*e)),p},a.prototype.readInt8=function(t,e){return t=t>>>0,e||v(t,1,this.length),this[t]&128?(255-this[t]+1)*-1:this[t]},a.prototype.readInt16LE=function(t,e){t=t>>>0,e||v(t,2,this.length);const o=this[t]|this[t+1]<<8;return o&32768?o|4294901760:o},a.prototype.readInt16BE=function(t,e){t=t>>>0,e||v(t,2,this.length);const o=this[t+1]|this[t]<<8;return o&32768?o|4294901760:o},a.prototype.readInt32LE=function(t,e){return t=t>>>0,e||v(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},a.prototype.readInt32BE=function(t,e){return t=t>>>0,e||v(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},a.prototype.readBigInt64LE=it(function(t){t=t>>>0,dt(t,"offset");const e=this[t],o=this[t+7];(e===void 0||o===void 0)&&bt(t,this.length-8);const l=this[t+4]+this[t+5]*2**8+this[t+6]*2**16+(o<<24);return(BigInt(l)<<BigInt(32))+BigInt(e+this[++t]*2**8+this[++t]*2**16+this[++t]*2**24)}),a.prototype.readBigInt64BE=it(function(t){t=t>>>0,dt(t,"offset");const e=this[t],o=this[t+7];(e===void 0||o===void 0)&&bt(t,this.length-8);const l=(e<<24)+this[++t]*2**16+this[++t]*2**8+this[++t];return(BigInt(l)<<BigInt(32))+BigInt(this[++t]*2**24+this[++t]*2**16+this[++t]*2**8+o)}),a.prototype.readFloatLE=function(t,e){return t=t>>>0,e||v(t,4,this.length),r.read(this,t,!0,23,4)},a.prototype.readFloatBE=function(t,e){return t=t>>>0,e||v(t,4,this.length),r.read(this,t,!1,23,4)},a.prototype.readDoubleLE=function(t,e){return t=t>>>0,e||v(t,8,this.length),r.read(this,t,!0,52,8)},a.prototype.readDoubleBE=function(t,e){return t=t>>>0,e||v(t,8,this.length),r.read(this,t,!1,52,8)};function j(i,t,e,o,l,f){if(!a.isBuffer(i))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>l||t<f)throw new RangeError('"value" argument is out of bounds');if(e+o>i.length)throw new RangeError("Index out of range")}a.prototype.writeUintLE=a.prototype.writeUIntLE=function(t,e,o,l){if(t=+t,e=e>>>0,o=o>>>0,!l){const S=Math.pow(2,8*o)-1;j(this,t,e,o,S,0)}let f=1,p=0;for(this[e]=t&255;++p<o&&(f*=256);)this[e+p]=t/f&255;return e+o},a.prototype.writeUintBE=a.prototype.writeUIntBE=function(t,e,o,l){if(t=+t,e=e>>>0,o=o>>>0,!l){const S=Math.pow(2,8*o)-1;j(this,t,e,o,S,0)}let f=o-1,p=1;for(this[e+f]=t&255;--f>=0&&(p*=256);)this[e+f]=t/p&255;return e+o},a.prototype.writeUint8=a.prototype.writeUInt8=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,1,255,0),this[e]=t&255,e+1},a.prototype.writeUint16LE=a.prototype.writeUInt16LE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,2,65535,0),this[e]=t&255,this[e+1]=t>>>8,e+2},a.prototype.writeUint16BE=a.prototype.writeUInt16BE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=t&255,e+2},a.prototype.writeUint32LE=a.prototype.writeUInt32LE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=t&255,e+4},a.prototype.writeUint32BE=a.prototype.writeUInt32BE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=t&255,e+4};function Jt(i,t,e,o,l){ee(t,o,l,i,e,7);let f=Number(t&BigInt(4294967295));i[e++]=f,f=f>>8,i[e++]=f,f=f>>8,i[e++]=f,f=f>>8,i[e++]=f;let p=Number(t>>BigInt(32)&BigInt(4294967295));return i[e++]=p,p=p>>8,i[e++]=p,p=p>>8,i[e++]=p,p=p>>8,i[e++]=p,e}function Yt(i,t,e,o,l){ee(t,o,l,i,e,7);let f=Number(t&BigInt(4294967295));i[e+7]=f,f=f>>8,i[e+6]=f,f=f>>8,i[e+5]=f,f=f>>8,i[e+4]=f;let p=Number(t>>BigInt(32)&BigInt(4294967295));return i[e+3]=p,p=p>>8,i[e+2]=p,p=p>>8,i[e+1]=p,p=p>>8,i[e]=p,e+8}a.prototype.writeBigUInt64LE=it(function(t,e=0){return Jt(this,t,e,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeBigUInt64BE=it(function(t,e=0){return Yt(this,t,e,BigInt(0),BigInt("0xffffffffffffffff"))}),a.prototype.writeIntLE=function(t,e,o,l){if(t=+t,e=e>>>0,!l){const K=Math.pow(2,8*o-1);j(this,t,e,o,K-1,-K)}let f=0,p=1,S=0;for(this[e]=t&255;++f<o&&(p*=256);)t<0&&S===0&&this[e+f-1]!==0&&(S=1),this[e+f]=(t/p>>0)-S&255;return e+o},a.prototype.writeIntBE=function(t,e,o,l){if(t=+t,e=e>>>0,!l){const K=Math.pow(2,8*o-1);j(this,t,e,o,K-1,-K)}let f=o-1,p=1,S=0;for(this[e+f]=t&255;--f>=0&&(p*=256);)t<0&&S===0&&this[e+f+1]!==0&&(S=1),this[e+f]=(t/p>>0)-S&255;return e+o},a.prototype.writeInt8=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=t&255,e+1},a.prototype.writeInt16LE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,2,32767,-32768),this[e]=t&255,this[e+1]=t>>>8,e+2},a.prototype.writeInt16BE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=t&255,e+2},a.prototype.writeInt32LE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,4,2147483647,-2147483648),this[e]=t&255,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},a.prototype.writeInt32BE=function(t,e,o){return t=+t,e=e>>>0,o||j(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=t&255,e+4},a.prototype.writeBigInt64LE=it(function(t,e=0){return Jt(this,t,e,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))}),a.prototype.writeBigInt64BE=it(function(t,e=0){return Yt(this,t,e,-BigInt("0x8000000000000000"),BigInt("0x7fffffffffffffff"))});function Xt(i,t,e,o,l,f){if(e+o>i.length)throw new RangeError("Index out of range");if(e<0)throw new RangeError("Index out of range")}function Zt(i,t,e,o,l){return t=+t,e=e>>>0,l||Xt(i,t,e,4),r.write(i,t,e,o,23,4),e+4}a.prototype.writeFloatLE=function(t,e,o){return Zt(this,t,e,!0,o)},a.prototype.writeFloatBE=function(t,e,o){return Zt(this,t,e,!1,o)};function Qt(i,t,e,o,l){return t=+t,e=e>>>0,l||Xt(i,t,e,8),r.write(i,t,e,o,52,8),e+8}a.prototype.writeDoubleLE=function(t,e,o){return Qt(this,t,e,!0,o)},a.prototype.writeDoubleBE=function(t,e,o){return Qt(this,t,e,!1,o)},a.prototype.copy=function(t,e,o,l){if(!a.isBuffer(t))throw new TypeError("argument should be a Buffer");if(o||(o=0),!l&&l!==0&&(l=this.length),e>=t.length&&(e=t.length),e||(e=0),l>0&&l<o&&(l=o),l===o||t.length===0||this.length===0)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(o<0||o>=this.length)throw new RangeError("Index out of range");if(l<0)throw new RangeError("sourceEnd out of bounds");l>this.length&&(l=this.length),t.length-e<l-o&&(l=t.length-e+o);const f=l-o;return this===t&&typeof Uint8Array.prototype.copyWithin=="function"?this.copyWithin(e,o,l):Uint8Array.prototype.set.call(t,this.subarray(o,l),e),f},a.prototype.fill=function(t,e,o,l){if(typeof t=="string"){if(typeof e=="string"?(l=e,e=0,o=this.length):typeof o=="string"&&(l=o,o=this.length),l!==void 0&&typeof l!="string")throw new TypeError("encoding must be a string");if(typeof l=="string"&&!a.isEncoding(l))throw new TypeError("Unknown encoding: "+l);if(t.length===1){const p=t.charCodeAt(0);(l==="utf8"&&p<128||l==="latin1")&&(t=p)}}else typeof t=="number"?t=t&255:typeof t=="boolean"&&(t=Number(t));if(e<0||this.length<e||this.length<o)throw new RangeError("Out of range index");if(o<=e)return this;e=e>>>0,o=o===void 0?this.length:o>>>0,t||(t=0);let f;if(typeof t=="number")for(f=e;f<o;++f)this[f]=t;else{const p=a.isBuffer(t)?t:a.from(t,l),S=p.length;if(S===0)throw new TypeError('The value "'+t+'" is invalid for argument "value"');for(f=0;f<o-e;++f)this[f+e]=p[f%S]}return this};const ht={};function _t(i,t,e){ht[i]=class extends e{constructor(){super(),Object.defineProperty(this,"message",{value:t.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${i}]`,this.stack,delete this.name}get code(){return i}set code(l){Object.defineProperty(this,"code",{configurable:!0,enumerable:!0,value:l,writable:!0})}toString(){return`${this.name} [${i}]: ${this.message}`}}}_t("ERR_BUFFER_OUT_OF_BOUNDS",function(i){return i?`${i} is outside of buffer bounds`:"Attempt to access memory outside buffer bounds"},RangeError),_t("ERR_INVALID_ARG_TYPE",function(i,t){return`The "${i}" argument must be of type number. Received type ${typeof t}`},TypeError),_t("ERR_OUT_OF_RANGE",function(i,t,e){let o=`The value of "${i}" is out of range.`,l=e;return Number.isInteger(e)&&Math.abs(e)>2**32?l=te(String(e)):typeof e=="bigint"&&(l=String(e),(e>BigInt(2)**BigInt(32)||e<-(BigInt(2)**BigInt(32)))&&(l=te(l)),l+="n"),o+=` It must be ${t}. Received ${l}`,o},RangeError);function te(i){let t="",e=i.length;const o=i[0]==="-"?1:0;for(;e>=o+4;e-=3)t=`_${i.slice(e-3,e)}${t}`;return`${i.slice(0,e)}${t}`}function Le(i,t,e){dt(t,"offset"),(i[t]===void 0||i[t+e]===void 0)&&bt(t,i.length-(e+1))}function ee(i,t,e,o,l,f){if(i>e||i<t){const p=typeof t=="bigint"?"n":"";let S;throw f>3?t===0||t===BigInt(0)?S=`>= 0${p} and < 2${p} ** ${(f+1)*8}${p}`:S=`>= -(2${p} ** ${(f+1)*8-1}${p}) and < 2 ** ${(f+1)*8-1}${p}`:S=`>= ${t}${p} and <= ${e}${p}`,new ht.ERR_OUT_OF_RANGE("value",S,i)}Le(o,l,f)}function dt(i,t){if(typeof i!="number")throw new ht.ERR_INVALID_ARG_TYPE(t,"number",i)}function bt(i,t,e){throw Math.floor(i)!==i?(dt(i,e),new ht.ERR_OUT_OF_RANGE(e||"offset","an integer",i)):t<0?new ht.ERR_BUFFER_OUT_OF_BOUNDS:new ht.ERR_OUT_OF_RANGE(e||"offset",`>= ${e?1:0} and <= ${t}`,i)}const Fe=/[^+/0-9A-Za-z-_]/g;function Pe(i){if(i=i.split("=")[0],i=i.trim().replace(Fe,""),i.length<2)return"";for(;i.length%4!==0;)i=i+"=";return i}function Tt(i,t){t=t||1/0;let e;const o=i.length;let l=null;const f=[];for(let p=0;p<o;++p){if(e=i.charCodeAt(p),e>55295&&e<57344){if(!l){if(e>56319){(t-=3)>-1&&f.push(239,191,189);continue}else if(p+1===o){(t-=3)>-1&&f.push(239,191,189);continue}l=e;continue}if(e<56320){(t-=3)>-1&&f.push(239,191,189),l=e;continue}e=(l-55296<<10|e-56320)+65536}else l&&(t-=3)>-1&&f.push(239,191,189);if(l=null,e<128){if((t-=1)<0)break;f.push(e)}else if(e<2048){if((t-=2)<0)break;f.push(e>>6|192,e&63|128)}else if(e<65536){if((t-=3)<0)break;f.push(e>>12|224,e>>6&63|128,e&63|128)}else if(e<1114112){if((t-=4)<0)break;f.push(e>>18|240,e>>12&63|128,e>>6&63|128,e&63|128)}else throw new Error("Invalid code point")}return f}function Ne(i){const t=[];for(let e=0;e<i.length;++e)t.push(i.charCodeAt(e)&255);return t}function De(i,t){let e,o,l;const f=[];for(let p=0;p<i.length&&!((t-=2)<0);++p)e=i.charCodeAt(p),o=e>>8,l=e%256,f.push(l),f.push(o);return f}function ne(i){return n.toByteArray(Pe(i))}function St(i,t,e,o){let l;for(l=0;l<o&&!(l+e>=t.length||l>=i.length);++l)t[l+e]=i[l];return l}function tt(i,t){return i instanceof t||i!=null&&i.constructor!=null&&i.constructor.name!=null&&i.constructor.name===t.name}function Ct(i){return i!==i}const Oe=function(){const i="0123456789abcdef",t=new Array(256);for(let e=0;e<16;++e){const o=e*16;for(let l=0;l<16;++l)t[o+l]=i[e]+i[l]}return t}();function it(i){return typeof BigInt>"u"?Ke:i}function Ke(){throw new Error("BigInt not supported")}})(Rn);Object.defineProperty(m,"__esModule",{value:!0});m.s16=m.s8=m.nu64be=m.u48be=m.u40be=m.u32be=m.u24be=m.u16be=st=m.nu64=m.u48=m.u40=P=m.u32=m.u24=pt=m.u16=V=m.u8=Ut=m.offset=m.greedy=m.Constant=m.UTF8=m.CString=m.Blob=m.Boolean=m.BitField=m.BitStructure=m.VariantLayout=m.Union=m.UnionLayoutDiscriminator=m.UnionDiscriminator=m.Structure=m.Sequence=m.DoubleBE=m.Double=m.FloatBE=m.Float=m.NearInt64BE=m.NearInt64=m.NearUInt64BE=m.NearUInt64=m.IntBE=m.Int=m.UIntBE=m.UInt=m.OffsetLayout=m.GreedyCount=m.ExternalLayout=m.bindConstructorLayout=m.nameWithProperty=m.Layout=m.uint8ArrayToBuffer=m.checkUint8Array=void 0;m.constant=m.utf8=m.cstr=Z=m.blob=m.unionLayoutDiscriminator=m.union=at=m.seq=m.bits=C=m.struct=m.f64be=m.f64=m.f32be=m.f32=m.ns64be=m.s48be=m.s40be=m.s32be=m.s24be=m.s16be=ft=m.ns64=m.s48=m.s40=m.s32=m.s24=void 0;const Ye=Rn;function $t(d){if(!(d instanceof Uint8Array))throw new TypeError("b must be a Uint8Array")}m.checkUint8Array=$t;function H(d){return $t(d),Ye.Buffer.from(d.buffer,d.byteOffset,d.length)}m.uint8ArrayToBuffer=H;class J{constructor(n,r){if(!Number.isInteger(n))throw new TypeError("span must be an integer");this.span=n,this.property=r}makeDestinationObject(){return{}}getSpan(n,r){if(0>this.span)throw new RangeError("indeterminate span");return this.span}replicate(n){const r=Object.create(this.constructor.prototype);return Object.assign(r,this),r.property=n,r}fromArray(n){}}m.Layout=J;function Xe(d,n){return n.property?d+"["+n.property+"]":d}m.nameWithProperty=Xe;function gr(d,n){if(typeof d!="function")throw new TypeError("Class must be constructor");if(Object.prototype.hasOwnProperty.call(d,"layout_"))throw new Error("Class is already bound to a layout");if(!(n&&n instanceof J))throw new TypeError("layout must be a Layout");if(Object.prototype.hasOwnProperty.call(n,"boundConstructor_"))throw new Error("layout is already bound to a constructor");d.layout_=n,n.boundConstructor_=d,n.makeDestinationObject=()=>new d,Object.defineProperty(d.prototype,"encode",{value(r,s){return n.encode(this,r,s)},writable:!0}),Object.defineProperty(d,"decode",{value(r,s){return n.decode(r,s)},writable:!0})}m.bindConstructorLayout=gr;class ut extends J{isCount(){throw new Error("ExternalLayout is abstract")}}m.ExternalLayout=ut;class _n extends ut{constructor(n=1,r){if(!Number.isInteger(n)||0>=n)throw new TypeError("elementSpan must be a (positive) integer");super(-1,r),this.elementSpan=n}isCount(){return!0}decode(n,r=0){$t(n);const s=n.length-r;return Math.floor(s/this.elementSpan)}encode(n,r,s){return 0}}m.GreedyCount=_n;class Ze extends ut{constructor(n,r=0,s){if(!(n instanceof J))throw new TypeError("layout must be a Layout");if(!Number.isInteger(r))throw new TypeError("offset must be integer or undefined");super(n.span,s||n.property),this.layout=n,this.offset=r}isCount(){return this.layout instanceof mt||this.layout instanceof Bt}decode(n,r=0){return this.layout.decode(n,r+this.offset)}encode(n,r,s=0){return this.layout.encode(n,r,s+this.offset)}}m.OffsetLayout=Ze;class mt extends J{constructor(n,r){if(super(n,r),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(n,r=0){return H(n).readUIntLE(r,this.span)}encode(n,r,s=0){return H(r).writeUIntLE(n,s,this.span),this.span}}m.UInt=mt;class Bt extends J{constructor(n,r){if(super(n,r),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(n,r=0){return H(n).readUIntBE(r,this.span)}encode(n,r,s=0){return H(r).writeUIntBE(n,s,this.span),this.span}}m.UIntBE=Bt;class Lt extends J{constructor(n,r){if(super(n,r),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(n,r=0){return H(n).readIntLE(r,this.span)}encode(n,r,s=0){return H(r).writeIntLE(n,s,this.span),this.span}}m.Int=Lt;class zt extends J{constructor(n,r){if(super(n,r),6<this.span)throw new RangeError("span must not exceed 6 bytes")}decode(n,r=0){return H(n).readIntBE(r,this.span)}encode(n,r,s=0){return H(r).writeIntBE(n,s,this.span),this.span}}m.IntBE=zt;const $e=Math.pow(2,32);function ye(d){const n=Math.floor(d/$e),r=d-n*$e;return{hi32:n,lo32:r}}function me(d,n){return d*$e+n}class Tn extends J{constructor(n){super(8,n)}decode(n,r=0){const s=H(n),c=s.readUInt32LE(r),u=s.readUInt32LE(r+4);return me(u,c)}encode(n,r,s=0){const c=ye(n),u=H(r);return u.writeUInt32LE(c.lo32,s),u.writeUInt32LE(c.hi32,s+4),8}}m.NearUInt64=Tn;class Cn extends J{constructor(n){super(8,n)}decode(n,r=0){const s=H(n),c=s.readUInt32BE(r),u=s.readUInt32BE(r+4);return me(c,u)}encode(n,r,s=0){const c=ye(n),u=H(r);return u.writeUInt32BE(c.hi32,s),u.writeUInt32BE(c.lo32,s+4),8}}m.NearUInt64BE=Cn;class Un extends J{constructor(n){super(8,n)}decode(n,r=0){const s=H(n),c=s.readUInt32LE(r),u=s.readInt32LE(r+4);return me(u,c)}encode(n,r,s=0){const c=ye(n),u=H(r);return u.writeUInt32LE(c.lo32,s),u.writeInt32LE(c.hi32,s+4),8}}m.NearInt64=Un;class Ln extends J{constructor(n){super(8,n)}decode(n,r=0){const s=H(n),c=s.readInt32BE(r),u=s.readUInt32BE(r+4);return me(c,u)}encode(n,r,s=0){const c=ye(n),u=H(r);return u.writeInt32BE(c.hi32,s),u.writeUInt32BE(c.lo32,s+4),8}}m.NearInt64BE=Ln;class Fn extends J{constructor(n){super(4,n)}decode(n,r=0){return H(n).readFloatLE(r)}encode(n,r,s=0){return H(r).writeFloatLE(n,s),4}}m.Float=Fn;class Pn extends J{constructor(n){super(4,n)}decode(n,r=0){return H(n).readFloatBE(r)}encode(n,r,s=0){return H(r).writeFloatBE(n,s),4}}m.FloatBE=Pn;class Nn extends J{constructor(n){super(8,n)}decode(n,r=0){return H(n).readDoubleLE(r)}encode(n,r,s=0){return H(r).writeDoubleLE(n,s),8}}m.Double=Nn;class Dn extends J{constructor(n){super(8,n)}decode(n,r=0){return H(n).readDoubleBE(r)}encode(n,r,s=0){return H(r).writeDoubleBE(n,s),8}}m.DoubleBE=Dn;class On extends J{constructor(n,r,s){if(!(n instanceof J))throw new TypeError("elementLayout must be a Layout");if(!(r instanceof ut&&r.isCount()||Number.isInteger(r)&&0<=r))throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");let c=-1;!(r instanceof ut)&&0<n.span&&(c=r*n.span),super(c,s),this.elementLayout=n,this.count=r}getSpan(n,r=0){if(0<=this.span)return this.span;let s=0,c=this.count;if(c instanceof ut&&(c=c.decode(n,r)),0<this.elementLayout.span)s=c*this.elementLayout.span;else{let u=0;for(;u<c;)s+=this.elementLayout.getSpan(n,r+s),++u}return s}decode(n,r=0){const s=[];let c=0,u=this.count;for(u instanceof ut&&(u=u.decode(n,r));c<u;)s.push(this.elementLayout.decode(n,r)),r+=this.elementLayout.getSpan(n,r),c+=1;return s}encode(n,r,s=0){const c=this.elementLayout,u=n.reduce((h,a)=>h+c.encode(a,r,s+h),0);return this.count instanceof ut&&this.count.encode(n.length,r,s),u}}m.Sequence=On;class Kn extends J{constructor(n,r,s){if(!(Array.isArray(n)&&n.reduce((u,h)=>u&&h instanceof J,!0)))throw new TypeError("fields must be array of Layout instances");typeof r=="boolean"&&s===void 0&&(s=r,r=void 0);for(const u of n)if(0>u.span&&u.property===void 0)throw new Error("fields cannot contain unnamed variable-length layout");let c=-1;try{c=n.reduce((u,h)=>u+h.getSpan(),0)}catch{}super(c,r),this.fields=n,this.decodePrefixes=!!s}getSpan(n,r=0){if(0<=this.span)return this.span;let s=0;try{s=this.fields.reduce((c,u)=>{const h=u.getSpan(n,r);return r+=h,c+h},0)}catch{throw new RangeError("indeterminate span")}return s}decode(n,r=0){$t(n);const s=this.makeDestinationObject();for(const c of this.fields)if(c.property!==void 0&&(s[c.property]=c.decode(n,r)),r+=c.getSpan(n,r),this.decodePrefixes&&n.length===r)break;return s}encode(n,r,s=0){const c=s;let u=0,h=0;for(const a of this.fields){let g=a.span;if(h=0<g?g:0,a.property!==void 0){const E=n[a.property];E!==void 0&&(h=a.encode(E,r,s),0>g&&(g=a.getSpan(r,s)))}u=s,s+=g}return u+h-c}fromArray(n){const r=this.makeDestinationObject();for(const s of this.fields)s.property!==void 0&&0<n.length&&(r[s.property]=n.shift());return r}layoutFor(n){if(typeof n!="string")throw new TypeError("property must be string");for(const r of this.fields)if(r.property===n)return r}offsetOf(n){if(typeof n!="string")throw new TypeError("property must be string");let r=0;for(const s of this.fields){if(s.property===n)return r;0>s.span?r=-1:0<=r&&(r+=s.span)}}}m.Structure=Kn;class Qe{constructor(n){this.property=n}decode(n,r){throw new Error("UnionDiscriminator is abstract")}encode(n,r,s){throw new Error("UnionDiscriminator is abstract")}}m.UnionDiscriminator=Qe;class de extends Qe{constructor(n,r){if(!(n instanceof ut&&n.isCount()))throw new TypeError("layout must be an unsigned integer ExternalLayout");super(r||n.property||"variant"),this.layout=n}decode(n,r){return this.layout.decode(n,r)}encode(n,r,s){return this.layout.encode(n,r,s)}}m.UnionLayoutDiscriminator=de;class tn extends J{constructor(n,r,s){let c;if(n instanceof mt||n instanceof Bt)c=new de(new Ze(n));else if(n instanceof ut&&n.isCount())c=new de(n);else if(n instanceof Qe)c=n;else throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");if(r===void 0&&(r=null),!(r===null||r instanceof J))throw new TypeError("defaultLayout must be null or a Layout");if(r!==null){if(0>r.span)throw new Error("defaultLayout must have constant span");r.property===void 0&&(r=r.replicate("content"))}let u=-1;r&&(u=r.span,0<=u&&(n instanceof mt||n instanceof Bt)&&(u+=c.layout.span)),super(u,s),this.discriminator=c,this.usesPrefixDiscriminator=n instanceof mt||n instanceof Bt,this.defaultLayout=r,this.registry={};let h=this.defaultGetSourceVariant.bind(this);this.getSourceVariant=function(a){return h(a)},this.configGetSourceVariant=function(a){h=a.bind(this)}}getSpan(n,r=0){if(0<=this.span)return this.span;const s=this.getVariant(n,r);if(!s)throw new Error("unable to determine span for unrecognized variant");return s.getSpan(n,r)}defaultGetSourceVariant(n){if(Object.prototype.hasOwnProperty.call(n,this.discriminator.property)){if(this.defaultLayout&&this.defaultLayout.property&&Object.prototype.hasOwnProperty.call(n,this.defaultLayout.property))return;const r=this.registry[n[this.discriminator.property]];if(r&&(!r.layout||r.property&&Object.prototype.hasOwnProperty.call(n,r.property)))return r}else for(const r in this.registry){const s=this.registry[r];if(s.property&&Object.prototype.hasOwnProperty.call(n,s.property))return s}throw new Error("unable to infer src variant")}decode(n,r=0){let s;const c=this.discriminator,u=c.decode(n,r),h=this.registry[u];if(h===void 0){const a=this.defaultLayout;let g=0;this.usesPrefixDiscriminator&&(g=c.layout.span),s=this.makeDestinationObject(),s[c.property]=u,s[a.property]=a.decode(n,r+g)}else s=h.decode(n,r);return s}encode(n,r,s=0){const c=this.getSourceVariant(n);if(c===void 0){const u=this.discriminator,h=this.defaultLayout;let a=0;return this.usesPrefixDiscriminator&&(a=u.layout.span),u.encode(n[u.property],r,s),a+h.encode(n[h.property],r,s+a)}return c.encode(n,r,s)}addVariant(n,r,s){const c=new Mn(this,n,r,s);return this.registry[n]=c,c}getVariant(n,r=0){let s;return n instanceof Uint8Array?s=this.discriminator.decode(n,r):s=n,this.registry[s]}}m.Union=tn;class Mn extends J{constructor(n,r,s,c){if(!(n instanceof tn))throw new TypeError("union must be a Union");if(!Number.isInteger(r)||0>r)throw new TypeError("variant must be a (non-negative) integer");if(typeof s=="string"&&c===void 0&&(c=s,s=null),s){if(!(s instanceof J))throw new TypeError("layout must be a Layout");if(n.defaultLayout!==null&&0<=s.span&&s.span>n.defaultLayout.span)throw new Error("variant span exceeds span of containing union");if(typeof c!="string")throw new TypeError("variant must have a String property")}let u=n.span;0>n.span&&(u=s?s.span:0,0<=u&&n.usesPrefixDiscriminator&&(u+=n.discriminator.layout.span)),super(u,c),this.union=n,this.variant=r,this.layout=s||null}getSpan(n,r=0){if(0<=this.span)return this.span;let s=0;this.union.usesPrefixDiscriminator&&(s=this.union.discriminator.layout.span);let c=0;return this.layout&&(c=this.layout.getSpan(n,r+s)),s+c}decode(n,r=0){const s=this.makeDestinationObject();if(this!==this.union.getVariant(n,r))throw new Error("variant mismatch");let c=0;return this.union.usesPrefixDiscriminator&&(c=this.union.discriminator.layout.span),this.layout?s[this.property]=this.layout.decode(n,r+c):this.property?s[this.property]=!0:this.union.usesPrefixDiscriminator&&(s[this.union.discriminator.property]=this.variant),s}encode(n,r,s=0){let c=0;if(this.union.usesPrefixDiscriminator&&(c=this.union.discriminator.layout.span),this.layout&&!Object.prototype.hasOwnProperty.call(n,this.property))throw new TypeError("variant lacks property "+this.property);this.union.discriminator.encode(this.variant,r,s);let u=c;if(this.layout&&(this.layout.encode(n[this.property],r,s+c),u+=this.layout.getSpan(r,s+c),0<=this.union.span&&u>this.union.span))throw new Error("encoded variant overruns containing union");return u}fromArray(n){if(this.layout)return this.layout.fromArray(n)}}m.VariantLayout=Mn;function Nt(d){return 0>d&&(d+=4294967296),d}class en extends J{constructor(n,r,s){if(!(n instanceof mt||n instanceof Bt))throw new TypeError("word must be a UInt or UIntBE layout");if(typeof r=="string"&&s===void 0&&(s=r,r=!1),4<n.span)throw new RangeError("word cannot exceed 32 bits");super(n.span,s),this.word=n,this.msb=!!r,this.fields=[];let c=0;this._packedSetValue=function(u){return c=Nt(u),this},this._packedGetValue=function(){return c}}decode(n,r=0){const s=this.makeDestinationObject(),c=this.word.decode(n,r);this._packedSetValue(c);for(const u of this.fields)u.property!==void 0&&(s[u.property]=u.decode(n));return s}encode(n,r,s=0){const c=this.word.decode(r,s);this._packedSetValue(c);for(const u of this.fields)if(u.property!==void 0){const h=n[u.property];h!==void 0&&u.encode(h)}return this.word.encode(this._packedGetValue(),r,s)}addField(n,r){const s=new nn(this,n,r);return this.fields.push(s),s}addBoolean(n){const r=new qn(this,n);return this.fields.push(r),r}fieldFor(n){if(typeof n!="string")throw new TypeError("property must be string");for(const r of this.fields)if(r.property===n)return r}}m.BitStructure=en;class nn{constructor(n,r,s){if(!(n instanceof en))throw new TypeError("container must be a BitStructure");if(!Number.isInteger(r)||0>=r)throw new TypeError("bits must be positive integer");const c=8*n.span,u=n.fields.reduce((h,a)=>h+a.bits,0);if(r+u>c)throw new Error("bits too long for span remainder ("+(c-u)+" of "+c+" remain)");this.container=n,this.bits=r,this.valueMask=(1<<r)-1,r===32&&(this.valueMask=4294967295),this.start=u,this.container.msb&&(this.start=c-u-r),this.wordMask=Nt(this.valueMask<<this.start),this.property=s}decode(n,r){const s=this.container._packedGetValue();return Nt(s&this.wordMask)>>>this.start}encode(n){if(typeof n!="number"||!Number.isInteger(n)||n!==Nt(n&this.valueMask))throw new TypeError(Xe("BitField.encode",this)+" value must be integer not exceeding "+this.valueMask);const r=this.container._packedGetValue(),s=Nt(n<<this.start);this.container._packedSetValue(Nt(r&~this.wordMask)|s)}}m.BitField=nn;class qn extends nn{constructor(n,r){super(n,1,r)}decode(n,r){return!!super.decode(n,r)}encode(n){typeof n=="boolean"&&(n=+n),super.encode(n)}}m.Boolean=qn;class Wn extends J{constructor(n,r){if(!(n instanceof ut&&n.isCount()||Number.isInteger(n)&&0<=n))throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");let s=-1;n instanceof ut||(s=n),super(s,r),this.length=n}getSpan(n,r){let s=this.span;return 0>s&&(s=this.length.decode(n,r)),s}decode(n,r=0){let s=this.span;return 0>s&&(s=this.length.decode(n,r)),H(n).slice(r,r+s)}encode(n,r,s){let c=this.length;if(this.length instanceof ut&&(c=n.length),!(n instanceof Uint8Array&&c===n.length))throw new TypeError(Xe("Blob.encode",this)+" requires (length "+c+") Uint8Array as src");if(s+c>r.length)throw new RangeError("encoding overruns Uint8Array");const u=H(n);return H(r).write(u.toString("hex"),s,c,"hex"),this.length instanceof ut&&this.length.encode(c,r,s),c}}m.Blob=Wn;class $n extends J{constructor(n){super(-1,n)}getSpan(n,r=0){$t(n);let s=r;for(;s<n.length&&n[s]!==0;)s+=1;return 1+s-r}decode(n,r=0){const s=this.getSpan(n,r);return H(n).slice(r,r+s-1).toString("utf-8")}encode(n,r,s=0){typeof n!="string"&&(n=String(n));const c=Ye.Buffer.from(n,"utf8"),u=c.length;if(s+u>r.length)throw new RangeError("encoding overruns Buffer");const h=H(r);return c.copy(h,s),h[s+u]=0,u+1}}m.CString=$n;class zn extends J{constructor(n,r){if(typeof n=="string"&&r===void 0&&(r=n,n=void 0),n===void 0)n=-1;else if(!Number.isInteger(n))throw new TypeError("maxSpan must be an integer");super(-1,r),this.maxSpan=n}getSpan(n,r=0){return $t(n),n.length-r}decode(n,r=0){const s=this.getSpan(n,r);if(0<=this.maxSpan&&this.maxSpan<s)throw new RangeError("text length exceeds maxSpan");return H(n).slice(r,r+s).toString("utf-8")}encode(n,r,s=0){typeof n!="string"&&(n=String(n));const c=Ye.Buffer.from(n,"utf8"),u=c.length;if(0<=this.maxSpan&&this.maxSpan<u)throw new RangeError("text length exceeds maxSpan");if(s+u>r.length)throw new RangeError("encoding overruns Buffer");return c.copy(H(r),s),u}}m.UTF8=zn;class vn extends J{constructor(n,r){super(0,r),this.value=n}decode(n,r){return this.value}encode(n,r,s){return 0}}m.Constant=vn;m.greedy=(d,n)=>new _n(d,n);var Ut=m.offset=(d,n,r)=>new Ze(d,n,r),V=m.u8=d=>new mt(1,d),pt=m.u16=d=>new mt(2,d);m.u24=d=>new mt(3,d);var P=m.u32=d=>new mt(4,d);m.u40=d=>new mt(5,d);m.u48=d=>new mt(6,d);var st=m.nu64=d=>new Tn(d);m.u16be=d=>new Bt(2,d);m.u24be=d=>new Bt(3,d);m.u32be=d=>new Bt(4,d);m.u40be=d=>new Bt(5,d);m.u48be=d=>new Bt(6,d);m.nu64be=d=>new Cn(d);m.s8=d=>new Lt(1,d);m.s16=d=>new Lt(2,d);m.s24=d=>new Lt(3,d);m.s32=d=>new Lt(4,d);m.s40=d=>new Lt(5,d);m.s48=d=>new Lt(6,d);var ft=m.ns64=d=>new Un(d);m.s16be=d=>new zt(2,d);m.s24be=d=>new zt(3,d);m.s32be=d=>new zt(4,d);m.s40be=d=>new zt(5,d);m.s48be=d=>new zt(6,d);m.ns64be=d=>new Ln(d);m.f32=d=>new Fn(d);m.f32be=d=>new Pn(d);m.f64=d=>new Nn(d);m.f64be=d=>new Dn(d);var C=m.struct=(d,n,r)=>new Kn(d,n,r);m.bits=(d,n,r)=>new en(d,n,r);var at=m.seq=(d,n,r)=>new On(d,n,r);m.union=(d,n,r)=>new tn(d,n,r);m.unionLayoutDiscriminator=(d,n)=>new de(d,n);var Z=m.blob=(d,n)=>new Wn(d,n);m.cstr=d=>new $n(d);m.utf8=(d,n)=>new zn(d,n);m.constant=(d,n)=>new vn(d,n);Wt.utils.randomPrivateKey;const ln=()=>{const d=Wt.utils.randomPrivateKey(),n=ze(d),r=new Uint8Array(64);return r.set(d),r.set(n,32),{publicKey:n,secretKey:r}},ze=Wt.getPublicKey;function hn(d){try{return Wt.ExtendedPoint.fromHex(d),!0}catch{return!1}}const yr=(d,n)=>Wt.sign(d,n.slice(0,32)),mr=Wt.verify,Mt=d=>$.Buffer.isBuffer(d)?d:d instanceof Uint8Array?$.Buffer.from(d.buffer,d.byteOffset,d.byteLength):$.Buffer.from(d);class wr{constructor(n){Object.assign(this,n)}encode(){return $.Buffer.from(or(le,this))}static decode(n){return cr(le,this,n)}static decodeUnchecked(n){return ar(le,this,n)}}const le=new Map;let Gn;const br=32,Et=32;function Br(d){return d._bn!==void 0}let dn=1;Gn=Symbol.toStringTag;class O extends wr{constructor(n){if(super({}),this._bn=void 0,Br(n))this._bn=n._bn;else{if(typeof n=="string"){const r=ot.decode(n);if(r.length!=Et)throw new Error("Invalid public key input");this._bn=new un(r)}else this._bn=new un(n);if(this._bn.byteLength()>Et)throw new Error("Invalid public key input")}}static unique(){const n=new O(dn);return dn+=1,new O(n.toBuffer())}equals(n){return this._bn.eq(n._bn)}toBase58(){return ot.encode(this.toBytes())}toJSON(){return this.toBase58()}toBytes(){const n=this.toBuffer();return new Uint8Array(n.buffer,n.byteOffset,n.byteLength)}toBuffer(){const n=this._bn.toArrayLike($.Buffer);if(n.length===Et)return n;const r=$.Buffer.alloc(32);return n.copy(r,32-n.length),r}get[Gn](){return`PublicKey(${this.toString()})`}toString(){return this.toBase58()}static async createWithSeed(n,r,s){const c=$.Buffer.concat([n.toBuffer(),$.Buffer.from(r),s.toBuffer()]),u=an(c);return new O(u)}static createProgramAddressSync(n,r){let s=$.Buffer.alloc(0);n.forEach(function(u){if(u.length>br)throw new TypeError("Max seed length exceeded");s=$.Buffer.concat([s,Mt(u)])}),s=$.Buffer.concat([s,r.toBuffer(),$.Buffer.from("ProgramDerivedAddress")]);const c=an(s);if(hn(c))throw new Error("Invalid seeds, address must fall off the curve");return new O(c)}static async createProgramAddress(n,r){return this.createProgramAddressSync(n,r)}static findProgramAddressSync(n,r){let s=255,c;for(;s!=0;){try{const u=n.concat($.Buffer.from([s]));c=this.createProgramAddressSync(u,r)}catch(u){if(u instanceof TypeError)throw u;s--;continue}return[c,s]}throw new Error("Unable to find a viable program address nonce")}static async findProgramAddress(n,r){return this.findProgramAddressSync(n,r)}static isOnCurve(n){const r=new O(n);return hn(r.toBytes())}}O.default=new O("11111111111111111111111111111111");le.set(O,{kind:"struct",fields:[["_bn","u256"]]});new O("BPFLoader1111111111111111111111111111111111");const Kt=1280-40-8,Hn=127,ve=64;class Vn extends Error{constructor(n){super(`Signature ${n} has expired: block height exceeded.`),this.signature=void 0,this.signature=n}}Object.defineProperty(Vn.prototype,"name",{value:"TransactionExpiredBlockheightExceededError"});class jn extends Error{constructor(n,r){super(`Transaction was not confirmed in ${r.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${n} using the Solana Explorer or CLI tools.`),this.signature=void 0,this.signature=n}}Object.defineProperty(jn.prototype,"name",{value:"TransactionExpiredTimeoutError"});class ie extends Error{constructor(n){super(`Signature ${n} has expired: the nonce is no longer valid.`),this.signature=void 0,this.signature=n}}Object.defineProperty(ie.prototype,"name",{value:"TransactionExpiredNonceInvalidError"});class fe{constructor(n,r){this.staticAccountKeys=void 0,this.accountKeysFromLookups=void 0,this.staticAccountKeys=n,this.accountKeysFromLookups=r}keySegments(){const n=[this.staticAccountKeys];return this.accountKeysFromLookups&&(n.push(this.accountKeysFromLookups.writable),n.push(this.accountKeysFromLookups.readonly)),n}get(n){for(const r of this.keySegments()){if(n<r.length)return r[n];n-=r.length}}get length(){return this.keySegments().flat().length}compileInstructions(n){if(this.length>255+1)throw new Error("Account index overflow encountered during compilation");const s=new Map;this.keySegments().flat().forEach((u,h)=>{s.set(u.toBase58(),h)});const c=u=>{const h=s.get(u.toBase58());if(h===void 0)throw new Error("Encountered an unknown instruction account key during compilation");return h};return n.map(u=>({programIdIndex:c(u.programId),accountKeyIndexes:u.keys.map(h=>c(h.pubkey)),data:u.data}))}}const G=(d="publicKey")=>Z(32,d),Ot=(d="string")=>{const n=C([P("length"),P("lengthPadding"),Z(Ut(P(),-8),"chars")],d),r=n.decode.bind(n),s=n.encode.bind(n),c=n;return c.decode=(u,h)=>r(u,h).chars.toString(),c.encode=(u,h,a)=>{const g={chars:$.Buffer.from(u,"utf8")};return s(g,h,a)},c.alloc=u=>P().span+P().span+$.Buffer.from(u,"utf8").length,c},Er=(d="authorized")=>C([G("staker"),G("withdrawer")],d),Ir=(d="lockup")=>C([ft("unixTimestamp"),ft("epoch"),G("custodian")],d),Sr=(d="voteInit")=>C([G("nodePubkey"),G("authorizedVoter"),G("authorizedWithdrawer"),V("commission")],d),xr=(d="voteAuthorizeWithSeedArgs")=>C([P("voteAuthorizationType"),G("currentAuthorityDerivedKeyOwnerPubkey"),Ot("currentAuthorityDerivedKeySeed"),G("newAuthorized")],d);function gt(d){let n=0,r=0;for(;;){let s=d.shift();if(n|=(s&127)<<r*7,r+=1,!(s&128))break}return n}function yt(d,n){let r=n;for(;;){let s=r&127;if(r>>=7,r==0){d.push(s);break}else s|=128,d.push(s)}}function et(d,n){if(!d)throw new Error(n||"Assertion failed")}class we{constructor(n,r){this.payer=void 0,this.keyMetaMap=void 0,this.payer=n,this.keyMetaMap=r}static compile(n,r){const s=new Map,c=h=>{const a=h.toBase58();let g=s.get(a);return g===void 0&&(g={isSigner:!1,isWritable:!1,isInvoked:!1},s.set(a,g)),g},u=c(r);u.isSigner=!0,u.isWritable=!0;for(const h of n){c(h.programId).isInvoked=!0;for(const a of h.keys){const g=c(a.pubkey);g.isSigner||(g.isSigner=a.isSigner),g.isWritable||(g.isWritable=a.isWritable)}}return new we(r,s)}getMessageComponents(){const n=[...this.keyMetaMap.entries()];et(n.length<=256,"Max static account keys length exceeded");const r=n.filter(([,g])=>g.isSigner&&g.isWritable),s=n.filter(([,g])=>g.isSigner&&!g.isWritable),c=n.filter(([,g])=>!g.isSigner&&g.isWritable),u=n.filter(([,g])=>!g.isSigner&&!g.isWritable),h={numRequiredSignatures:r.length+s.length,numReadonlySignedAccounts:s.length,numReadonlyUnsignedAccounts:u.length};{et(r.length>0,"Expected at least one writable signer key");const[g]=r[0];et(g===this.payer.toBase58(),"Expected first writable signer key to be the fee payer")}const a=[...r.map(([g])=>new O(g)),...s.map(([g])=>new O(g)),...c.map(([g])=>new O(g)),...u.map(([g])=>new O(g))];return[h,a]}extractTableLookup(n){const[r,s]=this.drainKeysFoundInLookupTable(n.state.addresses,h=>!h.isSigner&&!h.isInvoked&&h.isWritable),[c,u]=this.drainKeysFoundInLookupTable(n.state.addresses,h=>!h.isSigner&&!h.isInvoked&&!h.isWritable);if(!(r.length===0&&c.length===0))return[{accountKey:n.key,writableIndexes:r,readonlyIndexes:c},{writable:s,readonly:u}]}drainKeysFoundInLookupTable(n,r){const s=new Array,c=new Array;for(const[u,h]of this.keyMetaMap.entries())if(r(h)){const a=new O(u),g=n.findIndex(E=>E.equals(a));g>=0&&(et(g<256,"Max lookup table index exceeded"),s.push(g),c.push(a),this.keyMetaMap.delete(u))}return[s,c]}}class At{constructor(n){this.header=void 0,this.accountKeys=void 0,this.recentBlockhash=void 0,this.instructions=void 0,this.indexToProgramIds=new Map,this.header=n.header,this.accountKeys=n.accountKeys.map(r=>new O(r)),this.recentBlockhash=n.recentBlockhash,this.instructions=n.instructions,this.instructions.forEach(r=>this.indexToProgramIds.set(r.programIdIndex,this.accountKeys[r.programIdIndex]))}get version(){return"legacy"}get staticAccountKeys(){return this.accountKeys}get compiledInstructions(){return this.instructions.map(n=>({programIdIndex:n.programIdIndex,accountKeyIndexes:n.accounts,data:ot.decode(n.data)}))}get addressTableLookups(){return[]}getAccountKeys(){return new fe(this.staticAccountKeys)}static compile(n){const r=we.compile(n.instructions,n.payerKey),[s,c]=r.getMessageComponents(),h=new fe(c).compileInstructions(n.instructions).map(a=>({programIdIndex:a.programIdIndex,accounts:a.accountKeyIndexes,data:ot.encode(a.data)}));return new At({header:s,accountKeys:c,recentBlockhash:n.recentBlockhash,instructions:h})}isAccountSigner(n){return n<this.header.numRequiredSignatures}isAccountWritable(n){const r=this.header.numRequiredSignatures;if(n>=this.header.numRequiredSignatures){const s=n-r,u=this.accountKeys.length-r-this.header.numReadonlyUnsignedAccounts;return s<u}else{const s=r-this.header.numReadonlySignedAccounts;return n<s}}isProgramId(n){return this.indexToProgramIds.has(n)}programIds(){return[...this.indexToProgramIds.values()]}nonProgramIds(){return this.accountKeys.filter((n,r)=>!this.isProgramId(r))}serialize(){const n=this.accountKeys.length;let r=[];yt(r,n);const s=this.instructions.map(U=>{const{accounts:q,programIdIndex:R}=U,A=Array.from(ot.decode(U.data));let b=[];yt(b,q.length);let _=[];return yt(_,A.length),{programIdIndex:R,keyIndicesCount:$.Buffer.from(b),keyIndices:q,dataLength:$.Buffer.from(_),data:A}});let c=[];yt(c,s.length);let u=$.Buffer.alloc(Kt);$.Buffer.from(c).copy(u);let h=c.length;s.forEach(U=>{const R=C([V("programIdIndex"),Z(U.keyIndicesCount.length,"keyIndicesCount"),at(V("keyIndex"),U.keyIndices.length,"keyIndices"),Z(U.dataLength.length,"dataLength"),at(V("userdatum"),U.data.length,"data")]).encode(U,u,h);h+=R}),u=u.slice(0,h);const a=C([Z(1,"numRequiredSignatures"),Z(1,"numReadonlySignedAccounts"),Z(1,"numReadonlyUnsignedAccounts"),Z(r.length,"keyCount"),at(G("key"),n,"keys"),G("recentBlockhash")]),g={numRequiredSignatures:$.Buffer.from([this.header.numRequiredSignatures]),numReadonlySignedAccounts:$.Buffer.from([this.header.numReadonlySignedAccounts]),numReadonlyUnsignedAccounts:$.Buffer.from([this.header.numReadonlyUnsignedAccounts]),keyCount:$.Buffer.from(r),keys:this.accountKeys.map(U=>Mt(U.toBytes())),recentBlockhash:ot.decode(this.recentBlockhash)};let E=$.Buffer.alloc(2048);const F=a.encode(g,E);return u.copy(E,F),E.slice(0,F+u.length)}static from(n){let r=[...n];const s=r.shift();if(s!==(s&Hn))throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");const c=r.shift(),u=r.shift(),h=gt(r);let a=[];for(let q=0;q<h;q++){const R=r.slice(0,Et);r=r.slice(Et),a.push(new O($.Buffer.from(R)))}const g=r.slice(0,Et);r=r.slice(Et);const E=gt(r);let F=[];for(let q=0;q<E;q++){const R=r.shift(),A=gt(r),b=r.slice(0,A);r=r.slice(A);const _=gt(r),z=r.slice(0,_),rt=ot.encode($.Buffer.from(z));r=r.slice(_),F.push({programIdIndex:R,accounts:b,data:rt})}const U={header:{numRequiredSignatures:s,numReadonlySignedAccounts:c,numReadonlyUnsignedAccounts:u},recentBlockhash:ot.encode($.Buffer.from(g)),accountKeys:a,instructions:F};return new At(U)}}class pe{constructor(n){this.header=void 0,this.staticAccountKeys=void 0,this.recentBlockhash=void 0,this.compiledInstructions=void 0,this.addressTableLookups=void 0,this.header=n.header,this.staticAccountKeys=n.staticAccountKeys,this.recentBlockhash=n.recentBlockhash,this.compiledInstructions=n.compiledInstructions,this.addressTableLookups=n.addressTableLookups}get version(){return 0}get numAccountKeysFromLookups(){let n=0;for(const r of this.addressTableLookups)n+=r.readonlyIndexes.length+r.writableIndexes.length;return n}getAccountKeys(n){let r;if(n&&"accountKeysFromLookups"in n&&n.accountKeysFromLookups){if(this.numAccountKeysFromLookups!=n.accountKeysFromLookups.writable.length+n.accountKeysFromLookups.readonly.length)throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");r=n.accountKeysFromLookups}else if(n&&"addressLookupTableAccounts"in n&&n.addressLookupTableAccounts)r=this.resolveAddressTableLookups(n.addressLookupTableAccounts);else if(this.addressTableLookups.length>0)throw new Error("Failed to get account keys because address table lookups were not resolved");return new fe(this.staticAccountKeys,r)}isAccountSigner(n){return n<this.header.numRequiredSignatures}isAccountWritable(n){const r=this.header.numRequiredSignatures,s=this.staticAccountKeys.length;if(n>=s){const c=n-s,u=this.addressTableLookups.reduce((h,a)=>h+a.writableIndexes.length,0);return c<u}else if(n>=this.header.numRequiredSignatures){const c=n-r,h=s-r-this.header.numReadonlyUnsignedAccounts;return c<h}else{const c=r-this.header.numReadonlySignedAccounts;return n<c}}resolveAddressTableLookups(n){const r={writable:[],readonly:[]};for(const s of this.addressTableLookups){const c=n.find(u=>u.key.equals(s.accountKey));if(!c)throw new Error(`Failed to find address lookup table account for table key ${s.accountKey.toBase58()}`);for(const u of s.writableIndexes)if(u<c.state.addresses.length)r.writable.push(c.state.addresses[u]);else throw new Error(`Failed to find address for index ${u} in address lookup table ${s.accountKey.toBase58()}`);for(const u of s.readonlyIndexes)if(u<c.state.addresses.length)r.readonly.push(c.state.addresses[u]);else throw new Error(`Failed to find address for index ${u} in address lookup table ${s.accountKey.toBase58()}`)}return r}static compile(n){const r=we.compile(n.instructions,n.payerKey),s=new Array,c={writable:new Array,readonly:new Array},u=n.addressLookupTableAccounts||[];for(const F of u){const U=r.extractTableLookup(F);if(U!==void 0){const[q,{writable:R,readonly:A}]=U;s.push(q),c.writable.push(...R),c.readonly.push(...A)}}const[h,a]=r.getMessageComponents(),E=new fe(a,c).compileInstructions(n.instructions);return new pe({header:h,staticAccountKeys:a,recentBlockhash:n.recentBlockhash,compiledInstructions:E,addressTableLookups:s})}serialize(){const n=Array();yt(n,this.staticAccountKeys.length);const r=this.serializeInstructions(),s=Array();yt(s,this.compiledInstructions.length);const c=this.serializeAddressTableLookups(),u=Array();yt(u,this.addressTableLookups.length);const h=C([V("prefix"),C([V("numRequiredSignatures"),V("numReadonlySignedAccounts"),V("numReadonlyUnsignedAccounts")],"header"),Z(n.length,"staticAccountKeysLength"),at(G(),this.staticAccountKeys.length,"staticAccountKeys"),G("recentBlockhash"),Z(s.length,"instructionsLength"),Z(r.length,"serializedInstructions"),Z(u.length,"addressTableLookupsLength"),Z(c.length,"serializedAddressTableLookups")]),a=new Uint8Array(Kt),g=128,E=h.encode({prefix:g,header:this.header,staticAccountKeysLength:new Uint8Array(n),staticAccountKeys:this.staticAccountKeys.map(F=>F.toBytes()),recentBlockhash:ot.decode(this.recentBlockhash),instructionsLength:new Uint8Array(s),serializedInstructions:r,addressTableLookupsLength:new Uint8Array(u),serializedAddressTableLookups:c},a);return a.slice(0,E)}serializeInstructions(){let n=0;const r=new Uint8Array(Kt);for(const s of this.compiledInstructions){const c=Array();yt(c,s.accountKeyIndexes.length);const u=Array();yt(u,s.data.length);const h=C([V("programIdIndex"),Z(c.length,"encodedAccountKeyIndexesLength"),at(V(),s.accountKeyIndexes.length,"accountKeyIndexes"),Z(u.length,"encodedDataLength"),Z(s.data.length,"data")]);n+=h.encode({programIdIndex:s.programIdIndex,encodedAccountKeyIndexesLength:new Uint8Array(c),accountKeyIndexes:s.accountKeyIndexes,encodedDataLength:new Uint8Array(u),data:s.data},r,n)}return r.slice(0,n)}serializeAddressTableLookups(){let n=0;const r=new Uint8Array(Kt);for(const s of this.addressTableLookups){const c=Array();yt(c,s.writableIndexes.length);const u=Array();yt(u,s.readonlyIndexes.length);const h=C([G("accountKey"),Z(c.length,"encodedWritableIndexesLength"),at(V(),s.writableIndexes.length,"writableIndexes"),Z(u.length,"encodedReadonlyIndexesLength"),at(V(),s.readonlyIndexes.length,"readonlyIndexes")]);n+=h.encode({accountKey:s.accountKey.toBytes(),encodedWritableIndexesLength:new Uint8Array(c),writableIndexes:s.writableIndexes,encodedReadonlyIndexesLength:new Uint8Array(u),readonlyIndexes:s.readonlyIndexes},r,n)}return r.slice(0,n)}static deserialize(n){let r=[...n];const s=r.shift(),c=s&Hn;et(s!==c,"Expected versioned message but received legacy message");const u=c;et(u===0,`Expected versioned message with version 0 but found version ${u}`);const h={numRequiredSignatures:r.shift(),numReadonlySignedAccounts:r.shift(),numReadonlyUnsignedAccounts:r.shift()},a=[],g=gt(r);for(let A=0;A<g;A++)a.push(new O(r.splice(0,Et)));const E=ot.encode(r.splice(0,Et)),F=gt(r),U=[];for(let A=0;A<F;A++){const b=r.shift(),_=gt(r),z=r.splice(0,_),rt=gt(r),wt=new Uint8Array(r.splice(0,rt));U.push({programIdIndex:b,accountKeyIndexes:z,data:wt})}const q=gt(r),R=[];for(let A=0;A<q;A++){const b=new O(r.splice(0,Et)),_=gt(r),z=r.splice(0,_),rt=gt(r),wt=r.splice(0,rt);R.push({accountKey:b,writableIndexes:z,readonlyIndexes:wt})}return new pe({header:h,staticAccountKeys:a,recentBlockhash:E,compiledInstructions:U,addressTableLookups:R})}}let xt=function(d){return d[d.BLOCKHEIGHT_EXCEEDED=0]="BLOCKHEIGHT_EXCEEDED",d[d.PROCESSED=1]="PROCESSED",d[d.TIMED_OUT=2]="TIMED_OUT",d[d.NONCE_INVALID=3]="NONCE_INVALID",d}({});const kr=$.Buffer.alloc(ve).fill(0);class fn{constructor(n){this.keys=void 0,this.programId=void 0,this.data=$.Buffer.alloc(0),this.programId=n.programId,this.keys=n.keys,n.data&&(this.data=n.data)}toJSON(){return{keys:this.keys.map(({pubkey:n,isSigner:r,isWritable:s})=>({pubkey:n.toJSON(),isSigner:r,isWritable:s})),programId:this.programId.toJSON(),data:[...this.data]}}}class kt{get signature(){return this.signatures.length>0?this.signatures[0].signature:null}constructor(n){if(this.signatures=[],this.feePayer=void 0,this.instructions=[],this.recentBlockhash=void 0,this.lastValidBlockHeight=void 0,this.nonceInfo=void 0,this.minNonceContextSlot=void 0,this._message=void 0,this._json=void 0,!!n)if(n.feePayer&&(this.feePayer=n.feePayer),n.signatures&&(this.signatures=n.signatures),Object.prototype.hasOwnProperty.call(n,"nonceInfo")){const{minContextSlot:r,nonceInfo:s}=n;this.minNonceContextSlot=r,this.nonceInfo=s}else if(Object.prototype.hasOwnProperty.call(n,"lastValidBlockHeight")){const{blockhash:r,lastValidBlockHeight:s}=n;this.recentBlockhash=r,this.lastValidBlockHeight=s}else{const{recentBlockhash:r,nonceInfo:s}=n;s&&(this.nonceInfo=s),this.recentBlockhash=r}}toJSON(){return{recentBlockhash:this.recentBlockhash||null,feePayer:this.feePayer?this.feePayer.toJSON():null,nonceInfo:this.nonceInfo?{nonce:this.nonceInfo.nonce,nonceInstruction:this.nonceInfo.nonceInstruction.toJSON()}:null,instructions:this.instructions.map(n=>n.toJSON()),signers:this.signatures.map(({publicKey:n})=>n.toJSON())}}add(...n){if(n.length===0)throw new Error("No instructions");return n.forEach(r=>{"instructions"in r?this.instructions=this.instructions.concat(r.instructions):"data"in r&&"programId"in r&&"keys"in r?this.instructions.push(r):this.instructions.push(new fn(r))}),this}compileMessage(){if(this._message&&JSON.stringify(this.toJSON())===JSON.stringify(this._json))return this._message;let n,r;if(this.nonceInfo?(n=this.nonceInfo.nonce,this.instructions[0]!=this.nonceInfo.nonceInstruction?r=[this.nonceInfo.nonceInstruction,...this.instructions]:r=this.instructions):(n=this.recentBlockhash,r=this.instructions),!n)throw new Error("Transaction recentBlockhash required");r.length<1&&console.warn("No instructions provided");let s;if(this.feePayer)s=this.feePayer;else if(this.signatures.length>0&&this.signatures[0].publicKey)s=this.signatures[0].publicKey;else throw new Error("Transaction fee payer required");for(let b=0;b<r.length;b++)if(r[b].programId===void 0)throw new Error(`Transaction instruction index ${b} has undefined program id`);const c=[],u=[];r.forEach(b=>{b.keys.forEach(z=>{u.push({...z})});const _=b.programId.toString();c.includes(_)||c.push(_)}),c.forEach(b=>{u.push({pubkey:new O(b),isSigner:!1,isWritable:!1})});const h=[];u.forEach(b=>{const _=b.pubkey.toString(),z=h.findIndex(rt=>rt.pubkey.toString()===_);z>-1?(h[z].isWritable=h[z].isWritable||b.isWritable,h[z].isSigner=h[z].isSigner||b.isSigner):h.push(b)}),h.sort(function(b,_){if(b.isSigner!==_.isSigner)return b.isSigner?-1:1;if(b.isWritable!==_.isWritable)return b.isWritable?-1:1;const z={localeMatcher:"best fit",usage:"sort",sensitivity:"variant",ignorePunctuation:!1,numeric:!1,caseFirst:"lower"};return b.pubkey.toBase58().localeCompare(_.pubkey.toBase58(),"en",z)});const a=h.findIndex(b=>b.pubkey.equals(s));if(a>-1){const[b]=h.splice(a,1);b.isSigner=!0,b.isWritable=!0,h.unshift(b)}else h.unshift({pubkey:s,isSigner:!0,isWritable:!0});for(const b of this.signatures){const _=h.findIndex(z=>z.pubkey.equals(b.publicKey));if(_>-1)h[_].isSigner||(h[_].isSigner=!0,console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."));else throw new Error(`unknown signer: ${b.publicKey.toString()}`)}let g=0,E=0,F=0;const U=[],q=[];h.forEach(({pubkey:b,isSigner:_,isWritable:z})=>{_?(U.push(b.toString()),g+=1,z||(E+=1)):(q.push(b.toString()),z||(F+=1))});const R=U.concat(q),A=r.map(b=>{const{data:_,programId:z}=b;return{programIdIndex:R.indexOf(z.toString()),accounts:b.keys.map(rt=>R.indexOf(rt.pubkey.toString())),data:ot.encode(_)}});return A.forEach(b=>{et(b.programIdIndex>=0),b.accounts.forEach(_=>et(_>=0))}),new At({header:{numRequiredSignatures:g,numReadonlySignedAccounts:E,numReadonlyUnsignedAccounts:F},accountKeys:R,recentBlockhash:n,instructions:A})}_compile(){const n=this.compileMessage(),r=n.accountKeys.slice(0,n.header.numRequiredSignatures);return this.signatures.length===r.length&&this.signatures.every((c,u)=>r[u].equals(c.publicKey))||(this.signatures=r.map(s=>({signature:null,publicKey:s}))),n}serializeMessage(){return this._compile().serialize()}async getEstimatedFee(n){return(await n.getFeeForMessage(this.compileMessage())).value}setSigners(...n){if(n.length===0)throw new Error("No signers");const r=new Set;this.signatures=n.filter(s=>{const c=s.toString();return r.has(c)?!1:(r.add(c),!0)}).map(s=>({signature:null,publicKey:s}))}sign(...n){if(n.length===0)throw new Error("No signers");const r=new Set,s=[];for(const u of n){const h=u.publicKey.toString();r.has(h)||(r.add(h),s.push(u))}this.signatures=s.map(u=>({signature:null,publicKey:u.publicKey}));const c=this._compile();this._partialSign(c,...s)}partialSign(...n){if(n.length===0)throw new Error("No signers");const r=new Set,s=[];for(const u of n){const h=u.publicKey.toString();r.has(h)||(r.add(h),s.push(u))}const c=this._compile();this._partialSign(c,...s)}_partialSign(n,...r){const s=n.serialize();r.forEach(c=>{const u=yr(s,c.secretKey);this._addSignature(c.publicKey,Mt(u))})}addSignature(n,r){this._compile(),this._addSignature(n,r)}_addSignature(n,r){et(r.length===64);const s=this.signatures.findIndex(c=>n.equals(c.publicKey));if(s<0)throw new Error(`unknown signer: ${n.toString()}`);this.signatures[s].signature=$.Buffer.from(r)}verifySignatures(n){return this._verifySignatures(this.serializeMessage(),n===void 0?!0:n)}_verifySignatures(n,r){for(const{signature:s,publicKey:c}of this.signatures)if(s===null){if(r)return!1}else if(!mr(s,n,c.toBytes()))return!1;return!0}serialize(n){const{requireAllSignatures:r,verifySignatures:s}=Object.assign({requireAllSignatures:!0,verifySignatures:!0},n),c=this.serializeMessage();if(s&&!this._verifySignatures(c,r))throw new Error("Signature verification failed");return this._serialize(c)}_serialize(n){const{signatures:r}=this,s=[];yt(s,r.length);const c=s.length+r.length*64+n.length,u=$.Buffer.alloc(c);return et(r.length<256),$.Buffer.from(s).copy(u,0),r.forEach(({signature:h},a)=>{h!==null&&(et(h.length===64,"signature has invalid length"),$.Buffer.from(h).copy(u,s.length+a*64))}),n.copy(u,s.length+r.length*64),et(u.length<=Kt,`Transaction too large: ${u.length} > ${Kt}`),u}get keys(){return et(this.instructions.length===1),this.instructions[0].keys.map(n=>n.pubkey)}get programId(){return et(this.instructions.length===1),this.instructions[0].programId}get data(){return et(this.instructions.length===1),this.instructions[0].data}static from(n){let r=[...n];const s=gt(r);let c=[];for(let u=0;u<s;u++){const h=r.slice(0,ve);r=r.slice(ve),c.push(ot.encode($.Buffer.from(h)))}return kt.populate(At.from(r),c)}static populate(n,r=[]){const s=new kt;return s.recentBlockhash=n.recentBlockhash,n.header.numRequiredSignatures>0&&(s.feePayer=n.accountKeys[0]),r.forEach((c,u)=>{const h={signature:c==ot.encode(kr)?null:ot.decode(c),publicKey:n.accountKeys[u]};s.signatures.push(h)}),n.instructions.forEach(c=>{const u=c.accounts.map(h=>{const a=n.accountKeys[h];return{pubkey:a,isSigner:s.signatures.some(g=>g.publicKey.toString()===a.toString())||n.isAccountSigner(h),isWritable:n.isAccountWritable(h)}});s.instructions.push(new fn({keys:u,programId:n.accountKeys[c.programIdIndex],data:ot.decode(c.data)}))}),s._message=n,s._json=s.toJSON(),s}}const Ar=160,Rr=64,_r=Ar/Rr,Tr=1e3/_r;new O("SysvarC1ock11111111111111111111111111111111");new O("SysvarEpochSchedu1e111111111111111111111111");new O("Sysvar1nstructions1111111111111111111111111");new O("SysvarRecentB1ockHashes11111111111111111111");new O("SysvarRent111111111111111111111111111111111");new O("SysvarRewards111111111111111111111111111111");new O("SysvarS1otHashes111111111111111111111111111");new O("SysvarS1otHistory11111111111111111111111111");new O("SysvarStakeHistory1111111111111111111111111");function Dt(d){return new Promise(n=>setTimeout(n,d))}const Cr=st("lamportsPerSignature"),Jn=C([P("version"),P("state"),G("authorizedPubkey"),G("nonce"),C([Cr],"feeCalculator")]);Jn.span;class rn{constructor(n){this.authorizedPubkey=void 0,this.nonce=void 0,this.feeCalculator=void 0,this.authorizedPubkey=n.authorizedPubkey,this.nonce=n.nonce,this.feeCalculator=n.feeCalculator}static fromAccountData(n){const r=Jn.decode(Mt(n),0);return new rn({authorizedPubkey:new O(r.authorizedPubkey),nonce:new O(r.nonce).toString(),feeCalculator:r.feeCalculator})}}const Ur=d=>{const n=d.decode.bind(d),r=d.encode.bind(d);return{decode:n,encode:r}},Lr=d=>n=>{const r=Z(d,n),{encode:s,decode:c}=Ur(r),u=r;return u.decode=(h,a)=>{const g=c(h,a);return ur($.Buffer.from(g))},u.encode=(h,a,g)=>{const E=lr(h,d);return s(E,a,g)},u},qt=Lr(8);Object.freeze({Create:{index:0,layout:C([P("instruction"),ft("lamports"),ft("space"),G("programId")])},Assign:{index:1,layout:C([P("instruction"),G("programId")])},Transfer:{index:2,layout:C([P("instruction"),qt("lamports")])},CreateWithSeed:{index:3,layout:C([P("instruction"),G("base"),Ot("seed"),ft("lamports"),ft("space"),G("programId")])},AdvanceNonceAccount:{index:4,layout:C([P("instruction")])},WithdrawNonceAccount:{index:5,layout:C([P("instruction"),ft("lamports")])},InitializeNonceAccount:{index:6,layout:C([P("instruction"),G("authorized")])},AuthorizeNonceAccount:{index:7,layout:C([P("instruction"),G("authorized")])},Allocate:{index:8,layout:C([P("instruction"),ft("space")])},AllocateWithSeed:{index:9,layout:C([P("instruction"),G("base"),Ot("seed"),ft("space"),G("programId")])},AssignWithSeed:{index:10,layout:C([P("instruction"),G("base"),Ot("seed"),G("programId")])},TransferWithSeed:{index:11,layout:C([P("instruction"),qt("lamports"),Ot("seed"),G("programId")])},UpgradeNonceAccount:{index:12,layout:C([P("instruction")])}});new O("11111111111111111111111111111111");new O("BPFLoader2111111111111111111111111111111111");function Fr(d){return d&&d.__esModule&&Object.prototype.hasOwnProperty.call(d,"default")?d.default:d}var Pr=Object.prototype.toString,Nr=Object.keys||function(d){var n=[];for(var r in d)n.push(r);return n};function se(d,n){var r,s,c,u,h,a,g;if(d===!0)return"true";if(d===!1)return"false";switch(typeof d){case"object":if(d===null)return null;if(d.toJSON&&typeof d.toJSON=="function")return se(d.toJSON(),n);if(g=Pr.call(d),g==="[object Array]"){for(c="[",s=d.length-1,r=0;r<s;r++)c+=se(d[r],!0)+",";return s>-1&&(c+=se(d[r],!0)),c+"]"}else if(g==="[object Object]"){for(u=Nr(d).sort(),s=u.length,c="",r=0;r<s;)h=u[r],a=se(d[h],!1),a!==void 0&&(c&&(c+=","),c+=JSON.stringify(h)+":"+a),r++;return"{"+c+"}"}else return JSON.stringify(d);case"function":case"undefined":return n?null:void 0;case"string":return JSON.stringify(d);default:return isFinite(d)?d:null}}var Dr=function(d){var n=se(d,!1);if(n!==void 0)return""+n},pn=Fr(Dr);const re=32;function Me(d){let n=0;for(;d>1;)d/=2,n++;return n}function Or(d){return d===0?1:(d--,d|=d>>1,d|=d>>2,d|=d>>4,d|=d>>8,d|=d>>16,d|=d>>32,d+1)}class Kr{constructor(n,r,s,c,u){this.slotsPerEpoch=void 0,this.leaderScheduleSlotOffset=void 0,this.warmup=void 0,this.firstNormalEpoch=void 0,this.firstNormalSlot=void 0,this.slotsPerEpoch=n,this.leaderScheduleSlotOffset=r,this.warmup=s,this.firstNormalEpoch=c,this.firstNormalSlot=u}getEpoch(n){return this.getEpochAndSlotIndex(n)[0]}getEpochAndSlotIndex(n){if(n<this.firstNormalSlot){const r=Me(Or(n+re+1))-Me(re)-1,s=this.getSlotsInEpoch(r),c=n-(s-re);return[r,c]}else{const r=n-this.firstNormalSlot,s=Math.floor(r/this.slotsPerEpoch),c=this.firstNormalEpoch+s,u=r%this.slotsPerEpoch;return[c,u]}}getFirstSlotInEpoch(n){return n<=this.firstNormalEpoch?(Math.pow(2,n)-1)*re:(n-this.firstNormalEpoch)*this.slotsPerEpoch+this.firstNormalSlot}getLastSlotInEpoch(n){return this.getFirstSlotInEpoch(n)+this.getSlotsInEpoch(n)-1}getSlotsInEpoch(n){return n<this.firstNormalEpoch?Math.pow(2,n+Me(re)):this.slotsPerEpoch}}class gn extends Error{constructor(n,r){super(n),this.logs=void 0,this.logs=r}}class T extends Error{constructor({code:n,message:r,data:s},c){super(c!=null?`${c}: ${r}`:r),this.code=void 0,this.data=void 0,this.code=n,this.data=s,this.name="SolanaJSONRPCError"}}var Mr=globalThis.fetch;class qr extends fr{constructor(n,r,s){const c=u=>{const h=pr(u,{autoconnect:!0,max_reconnects:5,reconnect:!0,reconnect_interval:1e3,...r});return"socket"in h?this.underlyingSocket=h.socket:this.underlyingSocket=h,h};super(c,n,r,s),this.underlyingSocket=void 0}call(...n){var s;const r=(s=this.underlyingSocket)==null?void 0:s.readyState;return r===1?super.call(...n):Promise.reject(new Error("Tried to call a JSON-RPC method `"+n[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}notify(...n){var s;const r=(s=this.underlyingSocket)==null?void 0:s.readyState;return r===1?super.notify(...n):Promise.reject(new Error("Tried to send a JSON-RPC notification `"+n[0]+"` but the socket was not `CONNECTING` or `OPEN` (`readyState` was "+r+")"))}}function Wr(d,n){let r;try{r=d.layout.decode(n)}catch(s){throw new Error("invalid instruction; "+s)}if(r.typeIndex!==d.index)throw new Error(`invalid account data; account type mismatch ${r.typeIndex} != ${d.index}`);return r}const yn=56;class mn{constructor(n){this.key=void 0,this.state=void 0,this.key=n.key,this.state=n.state}isActive(){const n=BigInt("0xffffffffffffffff");return this.state.deactivationSlot===n}static deserialize(n){const r=Wr($r,n),s=n.length-yn;et(s>=0,"lookup table is invalid"),et(s%32===0,"lookup table is invalid");const c=s/32,{addresses:u}=C([at(G(),c,"addresses")]).decode(n.slice(yn));return{deactivationSlot:r.deactivationSlot,lastExtendedSlot:r.lastExtendedSlot,lastExtendedSlotStartIndex:r.lastExtendedStartIndex,authority:r.authority.length!==0?new O(r.authority[0]):void 0,addresses:u.map(h=>new O(h))}}}const $r={index:1,layout:C([P("typeIndex"),qt("deactivationSlot"),st("lastExtendedSlot"),V("lastExtendedStartIndex"),V(),at(G(),Ut(V(),-1),"authority")])},zr=/^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;function vr(d){const n=d.match(zr);if(n==null)throw TypeError(`Failed to validate endpoint URL \`${d}\``);const[r,s,c,u]=n,h=d.startsWith("https:")?"wss:":"ws:",a=c==null?null:parseInt(c.slice(1),10),g=a==null?"":`:${a+1}`;return`${h}//${s}${g}${u}`}const nt=ce(je(O),B(),d=>new O(d)),Yn=Je([B(),X("base64")]),sn=ce(je($.Buffer),Yn,d=>$.Buffer.from(d[0],"base64")),Gr=30*1e3;function Hr(d){if(/^https?:/.test(d)===!1)throw new TypeError("Endpoint URL must start with `http:` or `https:`.");return d}function Y(d){let n,r;if(typeof d=="string")n=d;else if(d){const{commitment:s,...c}=d;n=s,r=c}return{commitment:n,config:r}}function Xn(d){return lt([w({jsonrpc:X("2.0"),id:B(),result:d}),w({jsonrpc:X("2.0"),id:B(),error:w({code:ae(),message:B(),data:D(hr())})})])}const Vr=Xn(ae());function W(d){return ce(Xn(d),Vr,n=>"error"in n?n:{...n,result:I(n.result,d)})}function Q(d){return W(w({context:w({slot:y()}),value:d}))}function be(d){return w({context:w({slot:y()}),value:d})}function qe(d,n){return d===0?new pe({header:n.header,staticAccountKeys:n.accountKeys.map(r=>new O(r)),recentBlockhash:n.recentBlockhash,compiledInstructions:n.instructions.map(r=>({programIdIndex:r.programIdIndex,accountKeyIndexes:r.accounts,data:ot.decode(r.data)})),addressTableLookups:n.addressTableLookups}):new At(n)}const jr=w({foundation:y(),foundationTerm:y(),initial:y(),taper:y(),terminal:y()}),Jr=W(x(k(w({epoch:y(),effectiveSlot:y(),amount:y(),postBalance:y(),commission:D(k(y()))})))),Yr=x(w({slot:y(),prioritizationFee:y()})),Xr=w({total:y(),validator:y(),foundation:y(),epoch:y()}),Zr=w({epoch:y(),slotIndex:y(),slotsInEpoch:y(),absoluteSlot:y(),blockHeight:D(y()),transactionCount:D(y())}),Qr=w({slotsPerEpoch:y(),leaderScheduleSlotOffset:y(),warmup:It(),firstNormalEpoch:y(),firstNormalSlot:y()}),ti=An(B(),x(y())),Ft=k(lt([w({}),B()])),ei=w({err:Ft}),ni=X("receivedSignature"),ri=w({"solana-core":B(),"feature-set":D(y())}),wn=Q(w({err:k(lt([w({}),B()])),logs:k(x(B())),accounts:D(k(x(k(w({executable:It(),owner:B(),lamports:y(),data:x(B()),rentEpoch:D(y())}))))),unitsConsumed:D(y()),returnData:D(k(w({programId:B(),data:Je([B(),X("base64")])})))})),ii=Q(w({byIdentity:An(B(),x(y())),range:w({firstSlot:y(),lastSlot:y()})}));function si(d,n,r,s,c,u){const h=r||Mr;let a;u!=null&&console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments.");let g;return s&&(g=async(F,U)=>{const q=await new Promise((R,A)=>{try{s(F,U,(b,_)=>R([b,_]))}catch(b){A(b)}});return await h(...q)}),new dr(async(F,U)=>{const q={method:"POST",body:F,agent:a,headers:Object.assign({"Content-Type":"application/json"},n||{},os)};try{let R=5,A,b=500;for(;g?A=await g(d,q):A=await h(d,q),!(A.status!==429||c===!0||(R-=1,R===0));)console.log(`Server responded with ${A.status} ${A.statusText}.  Retrying after ${b}ms delay...`),await Dt(b),b*=2;const _=await A.text();A.ok?U(null,_):U(new Error(`${A.status} ${A.statusText}: ${_}`))}catch(R){R instanceof Error&&U(R)}},{})}function oi(d){return(n,r)=>new Promise((s,c)=>{d.request(n,r,(u,h)=>{if(u){c(u);return}s(h)})})}function ci(d){return n=>new Promise((r,s)=>{n.length===0&&r([]);const c=n.map(u=>d.request(u.methodName,u.args));d.request(c,(u,h)=>{if(u){s(u);return}r(h)})})}const ai=W(jr),ui=W(Xr),li=W(Yr),hi=W(Zr),di=W(Qr),fi=W(ti),pi=W(y()),gi=Q(w({total:y(),circulating:y(),nonCirculating:y(),nonCirculatingAccounts:x(nt)})),Ge=w({amount:B(),uiAmount:k(y()),decimals:y(),uiAmountString:D(B())}),yi=Q(x(w({address:nt,amount:B(),uiAmount:k(y()),decimals:y(),uiAmountString:D(B())}))),mi=Q(x(w({pubkey:nt,account:w({executable:It(),owner:nt,lamports:y(),data:sn,rentEpoch:y()})}))),He=w({program:B(),parsed:ae(),space:y()}),wi=Q(x(w({pubkey:nt,account:w({executable:It(),owner:nt,lamports:y(),data:He,rentEpoch:y()})}))),bi=Q(x(w({lamports:y(),address:nt}))),oe=w({executable:It(),owner:nt,lamports:y(),data:sn,rentEpoch:y()}),Bi=w({pubkey:nt,account:oe}),Ei=ce(lt([je($.Buffer),He]),lt([Yn,He]),d=>Array.isArray(d)?I(d,sn):d),Ve=w({executable:It(),owner:nt,lamports:y(),data:Ei,rentEpoch:y()}),Ii=w({pubkey:nt,account:Ve}),Si=w({state:lt([X("active"),X("inactive"),X("activating"),X("deactivating")]),active:y(),inactive:y()}),xi=W(x(w({signature:B(),slot:y(),err:Ft,memo:k(B()),blockTime:D(k(y()))}))),ki=W(x(w({signature:B(),slot:y(),err:Ft,memo:k(B()),blockTime:D(k(y()))}))),Ai=w({subscription:y(),result:be(oe)}),Ri=w({pubkey:nt,account:oe}),_i=w({subscription:y(),result:be(Ri)}),Ti=w({parent:y(),slot:y(),root:y()}),Ci=w({subscription:y(),result:Ti}),Ui=lt([w({type:lt([X("firstShredReceived"),X("completed"),X("optimisticConfirmation"),X("root")]),slot:y(),timestamp:y()}),w({type:X("createdBank"),parent:y(),slot:y(),timestamp:y()}),w({type:X("frozen"),slot:y(),timestamp:y(),stats:w({numTransactionEntries:y(),numSuccessfulTransactions:y(),numFailedTransactions:y(),maxTransactionsPerEntry:y()})}),w({type:X("dead"),slot:y(),timestamp:y(),err:B()})]),Li=w({subscription:y(),result:Ui}),Fi=w({subscription:y(),result:be(lt([ei,ni]))}),Pi=w({subscription:y(),result:y()}),Ni=w({pubkey:B(),gossip:k(B()),tpu:k(B()),rpc:k(B()),version:k(B())}),bn=w({votePubkey:B(),nodePubkey:B(),activatedStake:y(),epochVoteAccount:It(),epochCredits:x(Je([y(),y(),y()])),commission:y(),lastVote:y(),rootSlot:k(y())}),Di=W(w({current:x(bn),delinquent:x(bn)})),Oi=lt([X("processed"),X("confirmed"),X("finalized")]),Ki=w({slot:y(),confirmations:k(y()),err:Ft,confirmationStatus:D(Oi)}),Mi=Q(x(k(Ki))),qi=W(y()),Zn=w({accountKey:nt,writableIndexes:x(y()),readonlyIndexes:x(y())}),on=w({signatures:x(B()),message:w({accountKeys:x(B()),header:w({numRequiredSignatures:y(),numReadonlySignedAccounts:y(),numReadonlyUnsignedAccounts:y()}),instructions:x(w({accounts:x(y()),data:B(),programIdIndex:y()})),recentBlockhash:B(),addressTableLookups:D(x(Zn))})}),Qn=w({pubkey:nt,signer:It(),writable:It(),source:D(lt([X("transaction"),X("lookupTable")]))}),tr=w({accountKeys:x(Qn),signatures:x(B())}),er=w({parsed:ae(),program:B(),programId:nt}),nr=w({accounts:x(nt),data:B(),programId:nt}),Wi=lt([nr,er]),$i=lt([w({parsed:ae(),program:B(),programId:B()}),w({accounts:x(B()),data:B(),programId:B()})]),rr=ce(Wi,$i,d=>"accounts"in d?I(d,nr):I(d,er)),ir=w({signatures:x(B()),message:w({accountKeys:x(Qn),instructions:x(rr),recentBlockhash:B(),addressTableLookups:D(k(x(Zn)))})}),ge=w({accountIndex:y(),mint:B(),owner:D(B()),uiTokenAmount:Ge}),sr=w({writable:x(nt),readonly:x(nt)}),Be=w({err:Ft,fee:y(),innerInstructions:D(k(x(w({index:y(),instructions:x(w({accounts:x(y()),data:B(),programIdIndex:y()}))})))),preBalances:x(y()),postBalances:x(y()),logMessages:D(k(x(B()))),preTokenBalances:D(k(x(ge))),postTokenBalances:D(k(x(ge))),loadedAddresses:D(sr),computeUnitsConsumed:D(y())}),cn=w({err:Ft,fee:y(),innerInstructions:D(k(x(w({index:y(),instructions:x(rr)})))),preBalances:x(y()),postBalances:x(y()),logMessages:D(k(x(B()))),preTokenBalances:D(k(x(ge))),postTokenBalances:D(k(x(ge))),loadedAddresses:D(sr),computeUnitsConsumed:D(y())}),vt=lt([X(0),X("legacy")]),Pt=w({pubkey:B(),lamports:y(),postBalance:k(y()),rewardType:k(B()),commission:D(k(y()))}),zi=W(k(w({blockhash:B(),previousBlockhash:B(),parentSlot:y(),transactions:x(w({transaction:on,meta:k(Be),version:D(vt)})),rewards:D(x(Pt)),blockTime:k(y()),blockHeight:k(y())}))),vi=W(k(w({blockhash:B(),previousBlockhash:B(),parentSlot:y(),rewards:D(x(Pt)),blockTime:k(y()),blockHeight:k(y())}))),Gi=W(k(w({blockhash:B(),previousBlockhash:B(),parentSlot:y(),transactions:x(w({transaction:tr,meta:k(Be),version:D(vt)})),rewards:D(x(Pt)),blockTime:k(y()),blockHeight:k(y())}))),Hi=W(k(w({blockhash:B(),previousBlockhash:B(),parentSlot:y(),transactions:x(w({transaction:ir,meta:k(cn),version:D(vt)})),rewards:D(x(Pt)),blockTime:k(y()),blockHeight:k(y())}))),Vi=W(k(w({blockhash:B(),previousBlockhash:B(),parentSlot:y(),transactions:x(w({transaction:tr,meta:k(cn),version:D(vt)})),rewards:D(x(Pt)),blockTime:k(y()),blockHeight:k(y())}))),ji=W(k(w({blockhash:B(),previousBlockhash:B(),parentSlot:y(),rewards:D(x(Pt)),blockTime:k(y()),blockHeight:k(y())}))),Ji=W(k(w({blockhash:B(),previousBlockhash:B(),parentSlot:y(),transactions:x(w({transaction:on,meta:k(Be)})),rewards:D(x(Pt)),blockTime:k(y())}))),Bn=W(k(w({blockhash:B(),previousBlockhash:B(),parentSlot:y(),signatures:x(B()),blockTime:k(y())}))),We=W(k(w({slot:y(),meta:Be,blockTime:D(k(y())),transaction:on,version:D(vt)}))),ue=W(k(w({slot:y(),transaction:ir,meta:k(cn),blockTime:D(k(y())),version:D(vt)}))),Yi=Q(w({blockhash:B(),feeCalculator:w({lamportsPerSignature:y()})})),Xi=Q(w({blockhash:B(),lastValidBlockHeight:y()})),Zi=Q(It()),Qi=w({slot:y(),numTransactions:y(),numSlots:y(),samplePeriodSecs:y()}),ts=W(x(Qi)),es=Q(k(w({feeCalculator:w({lamportsPerSignature:y()})}))),ns=W(B()),rs=W(B()),is=w({err:Ft,logs:x(B()),signature:B()}),ss=w({result:be(is),subscription:y()}),os={"solana-client":"js/0.0.0-development"};class bs{constructor(n,r){this._commitment=void 0,this._confirmTransactionInitialTimeout=void 0,this._rpcEndpoint=void 0,this._rpcWsEndpoint=void 0,this._rpcClient=void 0,this._rpcRequest=void 0,this._rpcBatchRequest=void 0,this._rpcWebSocket=void 0,this._rpcWebSocketConnected=!1,this._rpcWebSocketHeartbeat=null,this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketGeneration=0,this._disableBlockhashCaching=!1,this._pollingBlockhash=!1,this._blockhashInfo={latestBlockhash:null,lastFetch:0,transactionSignatures:[],simulatedSignatures:[]},this._nextClientSubscriptionId=0,this._subscriptionDisposeFunctionsByClientSubscriptionId={},this._subscriptionHashByClientSubscriptionId={},this._subscriptionStateChangeCallbacksByHash={},this._subscriptionCallbacksByServerSubscriptionId={},this._subscriptionsByHash={},this._subscriptionsAutoDisposedByRpc=new Set,this.getBlockHeight=(()=>{const E={};return async F=>{const{commitment:U,config:q}=Y(F),R=this._buildArgs([],U,void 0,q),A=pn(R);return E[A]=E[A]??(async()=>{try{const b=await this._rpcRequest("getBlockHeight",R),_=I(b,W(y()));if("error"in _)throw new T(_.error,"failed to get block height information");return _.result}finally{delete E[A]}})(),await E[A]}})();let s,c,u,h,a,g;r&&typeof r=="string"?this._commitment=r:r&&(this._commitment=r.commitment,this._confirmTransactionInitialTimeout=r.confirmTransactionInitialTimeout,s=r.wsEndpoint,c=r.httpHeaders,u=r.fetch,h=r.fetchMiddleware,a=r.disableRetryOnRateLimit,g=r.httpAgent),this._rpcEndpoint=Hr(n),this._rpcWsEndpoint=s||vr(n),this._rpcClient=si(n,c,u,h,a,g),this._rpcRequest=oi(this._rpcClient),this._rpcBatchRequest=ci(this._rpcClient),this._rpcWebSocket=new qr(this._rpcWsEndpoint,{autoconnect:!1,max_reconnects:1/0}),this._rpcWebSocket.on("open",this._wsOnOpen.bind(this)),this._rpcWebSocket.on("error",this._wsOnError.bind(this)),this._rpcWebSocket.on("close",this._wsOnClose.bind(this)),this._rpcWebSocket.on("accountNotification",this._wsOnAccountNotification.bind(this)),this._rpcWebSocket.on("programNotification",this._wsOnProgramAccountNotification.bind(this)),this._rpcWebSocket.on("slotNotification",this._wsOnSlotNotification.bind(this)),this._rpcWebSocket.on("slotsUpdatesNotification",this._wsOnSlotUpdatesNotification.bind(this)),this._rpcWebSocket.on("signatureNotification",this._wsOnSignatureNotification.bind(this)),this._rpcWebSocket.on("rootNotification",this._wsOnRootNotification.bind(this)),this._rpcWebSocket.on("logsNotification",this._wsOnLogsNotification.bind(this))}get commitment(){return this._commitment}get rpcEndpoint(){return this._rpcEndpoint}async getBalanceAndContext(n,r){const{commitment:s,config:c}=Y(r),u=this._buildArgs([n.toBase58()],s,void 0,c),h=await this._rpcRequest("getBalance",u),a=I(h,Q(y()));if("error"in a)throw new T(a.error,`failed to get balance for ${n.toBase58()}`);return a.result}async getBalance(n,r){return await this.getBalanceAndContext(n,r).then(s=>s.value).catch(s=>{throw new Error("failed to get balance of account "+n.toBase58()+": "+s)})}async getBlockTime(n){const r=await this._rpcRequest("getBlockTime",[n]),s=I(r,W(k(y())));if("error"in s)throw new T(s.error,`failed to get block time for slot ${n}`);return s.result}async getMinimumLedgerSlot(){const n=await this._rpcRequest("minimumLedgerSlot",[]),r=I(n,W(y()));if("error"in r)throw new T(r.error,"failed to get minimum ledger slot");return r.result}async getFirstAvailableBlock(){const n=await this._rpcRequest("getFirstAvailableBlock",[]),r=I(n,pi);if("error"in r)throw new T(r.error,"failed to get first available block");return r.result}async getSupply(n){let r={};typeof n=="string"?r={commitment:n}:n?r={...n,commitment:n&&n.commitment||this.commitment}:r={commitment:this.commitment};const s=await this._rpcRequest("getSupply",[r]),c=I(s,gi);if("error"in c)throw new T(c.error,"failed to get supply");return c.result}async getTokenSupply(n,r){const s=this._buildArgs([n.toBase58()],r),c=await this._rpcRequest("getTokenSupply",s),u=I(c,Q(Ge));if("error"in u)throw new T(u.error,"failed to get token supply");return u.result}async getTokenAccountBalance(n,r){const s=this._buildArgs([n.toBase58()],r),c=await this._rpcRequest("getTokenAccountBalance",s),u=I(c,Q(Ge));if("error"in u)throw new T(u.error,"failed to get token account balance");return u.result}async getTokenAccountsByOwner(n,r,s){const{commitment:c,config:u}=Y(s);let h=[n.toBase58()];"mint"in r?h.push({mint:r.mint.toBase58()}):h.push({programId:r.programId.toBase58()});const a=this._buildArgs(h,c,"base64",u),g=await this._rpcRequest("getTokenAccountsByOwner",a),E=I(g,mi);if("error"in E)throw new T(E.error,`failed to get token accounts owned by account ${n.toBase58()}`);return E.result}async getParsedTokenAccountsByOwner(n,r,s){let c=[n.toBase58()];"mint"in r?c.push({mint:r.mint.toBase58()}):c.push({programId:r.programId.toBase58()});const u=this._buildArgs(c,s,"jsonParsed"),h=await this._rpcRequest("getTokenAccountsByOwner",u),a=I(h,wi);if("error"in a)throw new T(a.error,`failed to get token accounts owned by account ${n.toBase58()}`);return a.result}async getLargestAccounts(n){const r={...n,commitment:n&&n.commitment||this.commitment},s=r.filter||r.commitment?[r]:[],c=await this._rpcRequest("getLargestAccounts",s),u=I(c,bi);if("error"in u)throw new T(u.error,"failed to get largest accounts");return u.result}async getTokenLargestAccounts(n,r){const s=this._buildArgs([n.toBase58()],r),c=await this._rpcRequest("getTokenLargestAccounts",s),u=I(c,yi);if("error"in u)throw new T(u.error,"failed to get token largest accounts");return u.result}async getAccountInfoAndContext(n,r){const{commitment:s,config:c}=Y(r),u=this._buildArgs([n.toBase58()],s,"base64",c),h=await this._rpcRequest("getAccountInfo",u),a=I(h,Q(k(oe)));if("error"in a)throw new T(a.error,`failed to get info about account ${n.toBase58()}`);return a.result}async getParsedAccountInfo(n,r){const{commitment:s,config:c}=Y(r),u=this._buildArgs([n.toBase58()],s,"jsonParsed",c),h=await this._rpcRequest("getAccountInfo",u),a=I(h,Q(k(Ve)));if("error"in a)throw new T(a.error,`failed to get info about account ${n.toBase58()}`);return a.result}async getAccountInfo(n,r){try{return(await this.getAccountInfoAndContext(n,r)).value}catch(s){throw new Error("failed to get info about account "+n.toBase58()+": "+s)}}async getMultipleParsedAccounts(n,r){const{commitment:s,config:c}=Y(r),u=n.map(E=>E.toBase58()),h=this._buildArgs([u],s,"jsonParsed",c),a=await this._rpcRequest("getMultipleAccounts",h),g=I(a,Q(x(k(Ve))));if("error"in g)throw new T(g.error,`failed to get info for accounts ${u}`);return g.result}async getMultipleAccountsInfoAndContext(n,r){const{commitment:s,config:c}=Y(r),u=n.map(E=>E.toBase58()),h=this._buildArgs([u],s,"base64",c),a=await this._rpcRequest("getMultipleAccounts",h),g=I(a,Q(x(k(oe))));if("error"in g)throw new T(g.error,`failed to get info for accounts ${u}`);return g.result}async getMultipleAccountsInfo(n,r){return(await this.getMultipleAccountsInfoAndContext(n,r)).value}async getStakeActivation(n,r,s){const{commitment:c,config:u}=Y(r),h=this._buildArgs([n.toBase58()],c,void 0,{...u,epoch:s??(u==null?void 0:u.epoch)}),a=await this._rpcRequest("getStakeActivation",h),g=I(a,W(Si));if("error"in g)throw new T(g.error,`failed to get Stake Activation ${n.toBase58()}`);return g.result}async getProgramAccounts(n,r){const{commitment:s,config:c}=Y(r),{encoding:u,...h}=c||{},a=this._buildArgs([n.toBase58()],s,u||"base64",h),g=await this._rpcRequest("getProgramAccounts",a),E=x(Bi),F=h.withContext===!0?I(g,Q(E)):I(g,W(E));if("error"in F)throw new T(F.error,`failed to get accounts owned by program ${n.toBase58()}`);return F.result}async getParsedProgramAccounts(n,r){const{commitment:s,config:c}=Y(r),u=this._buildArgs([n.toBase58()],s,"jsonParsed",c),h=await this._rpcRequest("getProgramAccounts",u),a=I(h,W(x(Ii)));if("error"in a)throw new T(a.error,`failed to get accounts owned by program ${n.toBase58()}`);return a.result}async confirmTransaction(n,r){var u;let s;if(typeof n=="string")s=n;else{const h=n;if((u=h.abortSignal)!=null&&u.aborted)return Promise.reject(h.abortSignal.reason);s=h.signature}let c;try{c=ot.decode(s)}catch{throw new Error("signature must be base58 encoded: "+s)}return et(c.length===64,"signature has invalid length"),typeof n=="string"?await this.confirmTransactionUsingLegacyTimeoutStrategy({commitment:r||this.commitment,signature:s}):"lastValidBlockHeight"in n?await this.confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:r||this.commitment,strategy:n}):await this.confirmTransactionUsingDurableNonceStrategy({commitment:r||this.commitment,strategy:n})}getCancellationPromise(n){return new Promise((r,s)=>{n!=null&&(n.aborted?s(n.reason):n.addEventListener("abort",()=>{s(n.reason)}))})}getTransactionConfirmationPromise({commitment:n,signature:r}){let s,c,u=!1;const h=new Promise((g,E)=>{try{s=this.onSignature(r,(U,q)=>{s=void 0;const R={context:q,value:U};g({__type:xt.PROCESSED,response:R})},n);const F=new Promise(U=>{s==null?U():c=this._onSubscriptionStateChange(s,q=>{q==="subscribed"&&U()})});(async()=>{if(await F,u)return;const U=await this.getSignatureStatus(r);if(u||U==null)return;const{context:q,value:R}=U;if(R!=null)if(R!=null&&R.err)E(R.err);else{switch(n){case"confirmed":case"single":case"singleGossip":{if(R.confirmationStatus==="processed")return;break}case"finalized":case"max":case"root":{if(R.confirmationStatus==="processed"||R.confirmationStatus==="confirmed")return;break}case"processed":case"recent":}u=!0,g({__type:xt.PROCESSED,response:{context:q,value:R}})}})()}catch(F){E(F)}});return{abortConfirmation:()=>{c&&(c(),c=void 0),s!=null&&(this.removeSignatureListener(s),s=void 0)},confirmationPromise:h}}async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment:n,strategy:{abortSignal:r,lastValidBlockHeight:s,signature:c}}){let u=!1;const h=new Promise(U=>{const q=async()=>{try{return await this.getBlockHeight(n)}catch{return-1}};(async()=>{let R=await q();if(!u){for(;R<=s;)if(await Dt(1e3),u||(R=await q(),u))return;U({__type:xt.BLOCKHEIGHT_EXCEEDED})}})()}),{abortConfirmation:a,confirmationPromise:g}=this.getTransactionConfirmationPromise({commitment:n,signature:c}),E=this.getCancellationPromise(r);let F;try{const U=await Promise.race([E,g,h]);if(U.__type===xt.PROCESSED)F=U.response;else throw new Vn(c)}finally{u=!0,a()}return F}async confirmTransactionUsingDurableNonceStrategy({commitment:n,strategy:{abortSignal:r,minContextSlot:s,nonceAccountPubkey:c,nonceValue:u,signature:h}}){let a=!1;const g=new Promise(R=>{let A=u,b=null;const _=async()=>{try{const{context:z,value:rt}=await this.getNonceAndContext(c,{commitment:n,minContextSlot:s});return b=z.slot,rt==null?void 0:rt.nonce}catch{return A}};(async()=>{if(A=await _(),!a)for(;;){if(u!==A){R({__type:xt.NONCE_INVALID,slotInWhichNonceDidAdvance:b});return}if(await Dt(2e3),a||(A=await _(),a))return}})()}),{abortConfirmation:E,confirmationPromise:F}=this.getTransactionConfirmationPromise({commitment:n,signature:h}),U=this.getCancellationPromise(r);let q;try{const R=await Promise.race([U,F,g]);if(R.__type===xt.PROCESSED)q=R.response;else{let A;for(;;){const b=await this.getSignatureStatus(h);if(b==null)break;if(b.context.slot<(R.slotInWhichNonceDidAdvance??s)){await Dt(400);continue}A=b;break}if(A!=null&&A.value){const b=n||"finalized",{confirmationStatus:_}=A.value;switch(b){case"processed":case"recent":if(_!=="processed"&&_!=="confirmed"&&_!=="finalized")throw new ie(h);break;case"confirmed":case"single":case"singleGossip":if(_!=="confirmed"&&_!=="finalized")throw new ie(h);break;case"finalized":case"max":case"root":if(_!=="finalized")throw new ie(h);break;default:}q={context:A.context,value:{err:A.value.err}}}else throw new ie(h)}}finally{a=!0,E()}return q}async confirmTransactionUsingLegacyTimeoutStrategy({commitment:n,signature:r}){let s;const c=new Promise(g=>{let E=this._confirmTransactionInitialTimeout||6e4;switch(n){case"processed":case"recent":case"single":case"confirmed":case"singleGossip":{E=this._confirmTransactionInitialTimeout||3e4;break}}s=setTimeout(()=>g({__type:xt.TIMED_OUT,timeoutMs:E}),E)}),{abortConfirmation:u,confirmationPromise:h}=this.getTransactionConfirmationPromise({commitment:n,signature:r});let a;try{const g=await Promise.race([h,c]);if(g.__type===xt.PROCESSED)a=g.response;else throw new jn(r,g.timeoutMs/1e3)}finally{clearTimeout(s),u()}return a}async getClusterNodes(){const n=await this._rpcRequest("getClusterNodes",[]),r=I(n,W(x(Ni)));if("error"in r)throw new T(r.error,"failed to get cluster nodes");return r.result}async getVoteAccounts(n){const r=this._buildArgs([],n),s=await this._rpcRequest("getVoteAccounts",r),c=I(s,Di);if("error"in c)throw new T(c.error,"failed to get vote accounts");return c.result}async getSlot(n){const{commitment:r,config:s}=Y(n),c=this._buildArgs([],r,void 0,s),u=await this._rpcRequest("getSlot",c),h=I(u,W(y()));if("error"in h)throw new T(h.error,"failed to get slot");return h.result}async getSlotLeader(n){const{commitment:r,config:s}=Y(n),c=this._buildArgs([],r,void 0,s),u=await this._rpcRequest("getSlotLeader",c),h=I(u,W(B()));if("error"in h)throw new T(h.error,"failed to get slot leader");return h.result}async getSlotLeaders(n,r){const s=[n,r],c=await this._rpcRequest("getSlotLeaders",s),u=I(c,W(x(nt)));if("error"in u)throw new T(u.error,"failed to get slot leaders");return u.result}async getSignatureStatus(n,r){const{context:s,value:c}=await this.getSignatureStatuses([n],r);et(c.length===1);const u=c[0];return{context:s,value:u}}async getSignatureStatuses(n,r){const s=[n];r&&s.push(r);const c=await this._rpcRequest("getSignatureStatuses",s),u=I(c,Mi);if("error"in u)throw new T(u.error,"failed to get signature status");return u.result}async getTransactionCount(n){const{commitment:r,config:s}=Y(n),c=this._buildArgs([],r,void 0,s),u=await this._rpcRequest("getTransactionCount",c),h=I(u,W(y()));if("error"in h)throw new T(h.error,"failed to get transaction count");return h.result}async getTotalSupply(n){return(await this.getSupply({commitment:n,excludeNonCirculatingAccountsList:!0})).value.total}async getInflationGovernor(n){const r=this._buildArgs([],n),s=await this._rpcRequest("getInflationGovernor",r),c=I(s,ai);if("error"in c)throw new T(c.error,"failed to get inflation");return c.result}async getInflationReward(n,r,s){const{commitment:c,config:u}=Y(s),h=this._buildArgs([n.map(E=>E.toBase58())],c,void 0,{...u,epoch:r??(u==null?void 0:u.epoch)}),a=await this._rpcRequest("getInflationReward",h),g=I(a,Jr);if("error"in g)throw new T(g.error,"failed to get inflation reward");return g.result}async getInflationRate(){const n=await this._rpcRequest("getInflationRate",[]),r=I(n,ui);if("error"in r)throw new T(r.error,"failed to get inflation rate");return r.result}async getEpochInfo(n){const{commitment:r,config:s}=Y(n),c=this._buildArgs([],r,void 0,s),u=await this._rpcRequest("getEpochInfo",c),h=I(u,hi);if("error"in h)throw new T(h.error,"failed to get epoch info");return h.result}async getEpochSchedule(){const n=await this._rpcRequest("getEpochSchedule",[]),r=I(n,di);if("error"in r)throw new T(r.error,"failed to get epoch schedule");const s=r.result;return new Kr(s.slotsPerEpoch,s.leaderScheduleSlotOffset,s.warmup,s.firstNormalEpoch,s.firstNormalSlot)}async getLeaderSchedule(){const n=await this._rpcRequest("getLeaderSchedule",[]),r=I(n,fi);if("error"in r)throw new T(r.error,"failed to get leader schedule");return r.result}async getMinimumBalanceForRentExemption(n,r){const s=this._buildArgs([n],r),c=await this._rpcRequest("getMinimumBalanceForRentExemption",s),u=I(c,qi);return"error"in u?(console.warn("Unable to fetch minimum balance for rent exemption"),0):u.result}async getRecentBlockhashAndContext(n){const r=this._buildArgs([],n),s=await this._rpcRequest("getRecentBlockhash",r),c=I(s,Yi);if("error"in c)throw new T(c.error,"failed to get recent blockhash");return c.result}async getRecentPerformanceSamples(n){const r=await this._rpcRequest("getRecentPerformanceSamples",n?[n]:[]),s=I(r,ts);if("error"in s)throw new T(s.error,"failed to get recent performance samples");return s.result}async getFeeCalculatorForBlockhash(n,r){const s=this._buildArgs([n],r),c=await this._rpcRequest("getFeeCalculatorForBlockhash",s),u=I(c,es);if("error"in u)throw new T(u.error,"failed to get fee calculator");const{context:h,value:a}=u.result;return{context:h,value:a!==null?a.feeCalculator:null}}async getFeeForMessage(n,r){const s=Mt(n.serialize()).toString("base64"),c=this._buildArgs([s],r),u=await this._rpcRequest("getFeeForMessage",c),h=I(u,Q(k(y())));if("error"in h)throw new T(h.error,"failed to get fee for message");if(h.result===null)throw new Error("invalid blockhash");return h.result}async getRecentPrioritizationFees(n){var h;const r=(h=n==null?void 0:n.lockedWritableAccounts)==null?void 0:h.map(a=>a.toBase58()),s=this._buildArgs(r!=null&&r.length?[r]:[]),c=await this._rpcRequest("getRecentPrioritizationFees",s),u=I(c,li);if("error"in u)throw new T(u.error,"failed to get recent prioritization fees");return u.result}async getRecentBlockhash(n){try{return(await this.getRecentBlockhashAndContext(n)).value}catch(r){throw new Error("failed to get recent blockhash: "+r)}}async getLatestBlockhash(n){try{return(await this.getLatestBlockhashAndContext(n)).value}catch(r){throw new Error("failed to get recent blockhash: "+r)}}async getLatestBlockhashAndContext(n){const{commitment:r,config:s}=Y(n),c=this._buildArgs([],r,void 0,s),u=await this._rpcRequest("getLatestBlockhash",c),h=I(u,Xi);if("error"in h)throw new T(h.error,"failed to get latest blockhash");return h.result}async isBlockhashValid(n,r){const{commitment:s,config:c}=Y(r),u=this._buildArgs([n],s,void 0,c),h=await this._rpcRequest("isBlockhashValid",u),a=I(h,Zi);if("error"in a)throw new T(a.error,"failed to determine if the blockhash `"+n+"`is valid");return a.result}async getVersion(){const n=await this._rpcRequest("getVersion",[]),r=I(n,W(ri));if("error"in r)throw new T(r.error,"failed to get version");return r.result}async getGenesisHash(){const n=await this._rpcRequest("getGenesisHash",[]),r=I(n,W(B()));if("error"in r)throw new T(r.error,"failed to get genesis hash");return r.result}async getBlock(n,r){const{commitment:s,config:c}=Y(r),u=this._buildArgsAtLeastConfirmed([n],s,void 0,c),h=await this._rpcRequest("getBlock",u);try{switch(c==null?void 0:c.transactionDetails){case"accounts":{const a=I(h,Gi);if("error"in a)throw a.error;return a.result}case"none":{const a=I(h,vi);if("error"in a)throw a.error;return a.result}default:{const a=I(h,zi);if("error"in a)throw a.error;const{result:g}=a;return g?{...g,transactions:g.transactions.map(({transaction:E,meta:F,version:U})=>({meta:F,transaction:{...E,message:qe(U,E.message)},version:U}))}:null}}}catch(a){throw new T(a,"failed to get confirmed block")}}async getParsedBlock(n,r){const{commitment:s,config:c}=Y(r),u=this._buildArgsAtLeastConfirmed([n],s,"jsonParsed",c),h=await this._rpcRequest("getBlock",u);try{switch(c==null?void 0:c.transactionDetails){case"accounts":{const a=I(h,Vi);if("error"in a)throw a.error;return a.result}case"none":{const a=I(h,ji);if("error"in a)throw a.error;return a.result}default:{const a=I(h,Hi);if("error"in a)throw a.error;return a.result}}}catch(a){throw new T(a,"failed to get block")}}async getBlockProduction(n){let r,s;if(typeof n=="string")s=n;else if(n){const{commitment:a,...g}=n;s=a,r=g}const c=this._buildArgs([],s,"base64",r),u=await this._rpcRequest("getBlockProduction",c),h=I(u,ii);if("error"in h)throw new T(h.error,"failed to get block production information");return h.result}async getTransaction(n,r){const{commitment:s,config:c}=Y(r),u=this._buildArgsAtLeastConfirmed([n],s,void 0,c),h=await this._rpcRequest("getTransaction",u),a=I(h,We);if("error"in a)throw new T(a.error,"failed to get transaction");const g=a.result;return g&&{...g,transaction:{...g.transaction,message:qe(g.version,g.transaction.message)}}}async getParsedTransaction(n,r){const{commitment:s,config:c}=Y(r),u=this._buildArgsAtLeastConfirmed([n],s,"jsonParsed",c),h=await this._rpcRequest("getTransaction",u),a=I(h,ue);if("error"in a)throw new T(a.error,"failed to get transaction");return a.result}async getParsedTransactions(n,r){const{commitment:s,config:c}=Y(r),u=n.map(g=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([g],s,"jsonParsed",c)}));return(await this._rpcBatchRequest(u)).map(g=>{const E=I(g,ue);if("error"in E)throw new T(E.error,"failed to get transactions");return E.result})}async getTransactions(n,r){const{commitment:s,config:c}=Y(r),u=n.map(g=>({methodName:"getTransaction",args:this._buildArgsAtLeastConfirmed([g],s,void 0,c)}));return(await this._rpcBatchRequest(u)).map(g=>{const E=I(g,We);if("error"in E)throw new T(E.error,"failed to get transactions");const F=E.result;return F&&{...F,transaction:{...F.transaction,message:qe(F.version,F.transaction.message)}}})}async getConfirmedBlock(n,r){const s=this._buildArgsAtLeastConfirmed([n],r),c=await this._rpcRequest("getConfirmedBlock",s),u=I(c,Ji);if("error"in u)throw new T(u.error,"failed to get confirmed block");const h=u.result;if(!h)throw new Error("Confirmed block "+n+" not found");const a={...h,transactions:h.transactions.map(({transaction:g,meta:E})=>{const F=new At(g.message);return{meta:E,transaction:{...g,message:F}}})};return{...a,transactions:a.transactions.map(({transaction:g,meta:E})=>({meta:E,transaction:kt.populate(g.message,g.signatures)}))}}async getBlocks(n,r,s){const c=this._buildArgsAtLeastConfirmed(r!==void 0?[n,r]:[n],s),u=await this._rpcRequest("getBlocks",c),h=I(u,W(x(y())));if("error"in h)throw new T(h.error,"failed to get blocks");return h.result}async getBlockSignatures(n,r){const s=this._buildArgsAtLeastConfirmed([n],r,void 0,{transactionDetails:"signatures",rewards:!1}),c=await this._rpcRequest("getBlock",s),u=I(c,Bn);if("error"in u)throw new T(u.error,"failed to get block");const h=u.result;if(!h)throw new Error("Block "+n+" not found");return h}async getConfirmedBlockSignatures(n,r){const s=this._buildArgsAtLeastConfirmed([n],r,void 0,{transactionDetails:"signatures",rewards:!1}),c=await this._rpcRequest("getConfirmedBlock",s),u=I(c,Bn);if("error"in u)throw new T(u.error,"failed to get confirmed block");const h=u.result;if(!h)throw new Error("Confirmed block "+n+" not found");return h}async getConfirmedTransaction(n,r){const s=this._buildArgsAtLeastConfirmed([n],r),c=await this._rpcRequest("getConfirmedTransaction",s),u=I(c,We);if("error"in u)throw new T(u.error,"failed to get transaction");const h=u.result;if(!h)return h;const a=new At(h.transaction.message),g=h.transaction.signatures;return{...h,transaction:kt.populate(a,g)}}async getParsedConfirmedTransaction(n,r){const s=this._buildArgsAtLeastConfirmed([n],r,"jsonParsed"),c=await this._rpcRequest("getConfirmedTransaction",s),u=I(c,ue);if("error"in u)throw new T(u.error,"failed to get confirmed transaction");return u.result}async getParsedConfirmedTransactions(n,r){const s=n.map(h=>({methodName:"getConfirmedTransaction",args:this._buildArgsAtLeastConfirmed([h],r,"jsonParsed")}));return(await this._rpcBatchRequest(s)).map(h=>{const a=I(h,ue);if("error"in a)throw new T(a.error,"failed to get confirmed transactions");return a.result})}async getConfirmedSignaturesForAddress(n,r,s){let c={},u=await this.getFirstAvailableBlock();for(;!("until"in c)&&(r--,!(r<=0||r<u));)try{const g=await this.getConfirmedBlockSignatures(r,"finalized");g.signatures.length>0&&(c.until=g.signatures[g.signatures.length-1].toString())}catch(g){if(g instanceof Error&&g.message.includes("skipped"))continue;throw g}let h=await this.getSlot("finalized");for(;!("before"in c)&&(s++,!(s>h));)try{const g=await this.getConfirmedBlockSignatures(s);g.signatures.length>0&&(c.before=g.signatures[g.signatures.length-1].toString())}catch(g){if(g instanceof Error&&g.message.includes("skipped"))continue;throw g}return(await this.getConfirmedSignaturesForAddress2(n,c)).map(g=>g.signature)}async getConfirmedSignaturesForAddress2(n,r,s){const c=this._buildArgsAtLeastConfirmed([n.toBase58()],s,void 0,r),u=await this._rpcRequest("getConfirmedSignaturesForAddress2",c),h=I(u,xi);if("error"in h)throw new T(h.error,"failed to get confirmed signatures for address");return h.result}async getSignaturesForAddress(n,r,s){const c=this._buildArgsAtLeastConfirmed([n.toBase58()],s,void 0,r),u=await this._rpcRequest("getSignaturesForAddress",c),h=I(u,ki);if("error"in h)throw new T(h.error,"failed to get signatures for address");return h.result}async getAddressLookupTable(n,r){const{context:s,value:c}=await this.getAccountInfoAndContext(n,r);let u=null;return c!==null&&(u=new mn({key:n,state:mn.deserialize(c.data)})),{context:s,value:u}}async getNonceAndContext(n,r){const{context:s,value:c}=await this.getAccountInfoAndContext(n,r);let u=null;return c!==null&&(u=rn.fromAccountData(c.data)),{context:s,value:u}}async getNonce(n,r){return await this.getNonceAndContext(n,r).then(s=>s.value).catch(s=>{throw new Error("failed to get nonce for account "+n.toBase58()+": "+s)})}async requestAirdrop(n,r){const s=await this._rpcRequest("requestAirdrop",[n.toBase58(),r]),c=I(s,ns);if("error"in c)throw new T(c.error,`airdrop to ${n.toBase58()} failed`);return c.result}async _blockhashWithExpiryBlockHeight(n){if(!n){for(;this._pollingBlockhash;)await Dt(100);const s=Date.now()-this._blockhashInfo.lastFetch>=Gr;if(this._blockhashInfo.latestBlockhash!==null&&!s)return this._blockhashInfo.latestBlockhash}return await this._pollNewBlockhash()}async _pollNewBlockhash(){this._pollingBlockhash=!0;try{const n=Date.now(),r=this._blockhashInfo.latestBlockhash,s=r?r.blockhash:null;for(let c=0;c<50;c++){const u=await this.getLatestBlockhash("finalized");if(s!==u.blockhash)return this._blockhashInfo={latestBlockhash:u,lastFetch:Date.now(),transactionSignatures:[],simulatedSignatures:[]},u;await Dt(Tr/2)}throw new Error(`Unable to obtain a new blockhash after ${Date.now()-n}ms`)}finally{this._pollingBlockhash=!1}}async getStakeMinimumDelegation(n){const{commitment:r,config:s}=Y(n),c=this._buildArgs([],r,"base64",s),u=await this._rpcRequest("getStakeMinimumDelegation",c),h=I(u,Q(y()));if("error"in h)throw new T(h.error,"failed to get stake minimum delegation");return h.result}async simulateTransaction(n,r,s){if("message"in n){const b=n.serialize(),_=$.Buffer.from(b).toString("base64");if(Array.isArray(r)||s!==void 0)throw new Error("Invalid arguments");const z=r||{};z.encoding="base64","commitment"in z||(z.commitment=this.commitment);const rt=[_,z],wt=await this._rpcRequest("simulateTransaction",rt),Rt=I(wt,wn);if("error"in Rt)throw new Error("failed to simulate transaction: "+Rt.error.message);return Rt.result}let c;if(n instanceof kt){let A=n;c=new kt,c.feePayer=A.feePayer,c.instructions=n.instructions,c.nonceInfo=A.nonceInfo,c.signatures=A.signatures}else c=kt.populate(n),c._message=c._json=void 0;if(r!==void 0&&!Array.isArray(r))throw new Error("Invalid arguments");const u=r;if(c.nonceInfo&&u)c.sign(...u);else{let A=this._disableBlockhashCaching;for(;;){const b=await this._blockhashWithExpiryBlockHeight(A);if(c.lastValidBlockHeight=b.lastValidBlockHeight,c.recentBlockhash=b.blockhash,!u)break;if(c.sign(...u),!c.signature)throw new Error("!signature");const _=c.signature.toString("base64");if(!this._blockhashInfo.simulatedSignatures.includes(_)&&!this._blockhashInfo.transactionSignatures.includes(_)){this._blockhashInfo.simulatedSignatures.push(_);break}else A=!0}}const h=c._compile(),a=h.serialize(),E=c._serialize(a).toString("base64"),F={encoding:"base64",commitment:this.commitment};if(s){const A=(Array.isArray(s)?s:h.nonProgramIds()).map(b=>b.toBase58());F.accounts={encoding:"base64",addresses:A}}u&&(F.sigVerify=!0);const U=[E,F],q=await this._rpcRequest("simulateTransaction",U),R=I(q,wn);if("error"in R){let A;if("data"in R.error&&(A=R.error.data.logs,A&&Array.isArray(A))){const b=`
    `,_=b+A.join(b);console.error(R.error.message,_)}throw new gn("failed to simulate transaction: "+R.error.message,A)}return R.result}async sendTransaction(n,r,s){if("version"in n){if(r&&Array.isArray(r))throw new Error("Invalid arguments");const h=n.serialize();return await this.sendRawTransaction(h,r)}if(r===void 0||!Array.isArray(r))throw new Error("Invalid arguments");const c=r;if(n.nonceInfo)n.sign(...c);else{let h=this._disableBlockhashCaching;for(;;){const a=await this._blockhashWithExpiryBlockHeight(h);if(n.lastValidBlockHeight=a.lastValidBlockHeight,n.recentBlockhash=a.blockhash,n.sign(...c),!n.signature)throw new Error("!signature");const g=n.signature.toString("base64");if(this._blockhashInfo.transactionSignatures.includes(g))h=!0;else{this._blockhashInfo.transactionSignatures.push(g);break}}}const u=n.serialize();return await this.sendRawTransaction(u,s)}async sendRawTransaction(n,r){const s=Mt(n).toString("base64");return await this.sendEncodedTransaction(s,r)}async sendEncodedTransaction(n,r){const s={encoding:"base64"},c=r&&r.skipPreflight,u=r&&r.preflightCommitment||this.commitment;r&&r.maxRetries!=null&&(s.maxRetries=r.maxRetries),r&&r.minContextSlot!=null&&(s.minContextSlot=r.minContextSlot),c&&(s.skipPreflight=c),u&&(s.preflightCommitment=u);const h=[n,s],a=await this._rpcRequest("sendTransaction",h),g=I(a,rs);if("error"in g){let E;throw"data"in g.error&&(E=g.error.data.logs),new gn("failed to send transaction: "+g.error.message,E)}return g.result}_wsOnOpen(){this._rpcWebSocketConnected=!0,this._rpcWebSocketHeartbeat=setInterval(()=>{(async()=>{try{await this._rpcWebSocket.notify("ping")}catch{}})()},5e3),this._updateSubscriptions()}_wsOnError(n){this._rpcWebSocketConnected=!1,console.error("ws error:",n.message)}_wsOnClose(n){if(this._rpcWebSocketConnected=!1,this._rpcWebSocketGeneration=(this._rpcWebSocketGeneration+1)%Number.MAX_SAFE_INTEGER,this._rpcWebSocketIdleTimeout&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null),this._rpcWebSocketHeartbeat&&(clearInterval(this._rpcWebSocketHeartbeat),this._rpcWebSocketHeartbeat=null),n===1e3){this._updateSubscriptions();return}this._subscriptionCallbacksByServerSubscriptionId={},Object.entries(this._subscriptionsByHash).forEach(([r,s])=>{this._setSubscription(r,{...s,state:"pending"})})}_setSubscription(n,r){var c;const s=(c=this._subscriptionsByHash[n])==null?void 0:c.state;if(this._subscriptionsByHash[n]=r,s!==r.state){const u=this._subscriptionStateChangeCallbacksByHash[n];u&&u.forEach(h=>{try{h(r.state)}catch{}})}}_onSubscriptionStateChange(n,r){var u;const s=this._subscriptionHashByClientSubscriptionId[n];if(s==null)return()=>{};const c=(u=this._subscriptionStateChangeCallbacksByHash)[s]||(u[s]=new Set);return c.add(r),()=>{c.delete(r),c.size===0&&delete this._subscriptionStateChangeCallbacksByHash[s]}}async _updateSubscriptions(){if(Object.keys(this._subscriptionsByHash).length===0){this._rpcWebSocketConnected&&(this._rpcWebSocketConnected=!1,this._rpcWebSocketIdleTimeout=setTimeout(()=>{this._rpcWebSocketIdleTimeout=null;try{this._rpcWebSocket.close()}catch(s){s instanceof Error&&console.log(`Error when closing socket connection: ${s.message}`)}},500));return}if(this._rpcWebSocketIdleTimeout!==null&&(clearTimeout(this._rpcWebSocketIdleTimeout),this._rpcWebSocketIdleTimeout=null,this._rpcWebSocketConnected=!0),!this._rpcWebSocketConnected){this._rpcWebSocket.connect();return}const n=this._rpcWebSocketGeneration,r=()=>n===this._rpcWebSocketGeneration;await Promise.all(Object.keys(this._subscriptionsByHash).map(async s=>{const c=this._subscriptionsByHash[s];if(c!==void 0)switch(c.state){case"pending":case"unsubscribed":if(c.callbacks.size===0){delete this._subscriptionsByHash[s],c.state==="unsubscribed"&&delete this._subscriptionCallbacksByServerSubscriptionId[c.serverSubscriptionId],await this._updateSubscriptions();return}await(async()=>{const{args:u,method:h}=c;try{this._setSubscription(s,{...c,state:"subscribing"});const a=await this._rpcWebSocket.call(h,u);this._setSubscription(s,{...c,serverSubscriptionId:a,state:"subscribed"}),this._subscriptionCallbacksByServerSubscriptionId[a]=c.callbacks,await this._updateSubscriptions()}catch(a){if(a instanceof Error&&console.error(`${h} error for argument`,u,a.message),!r())return;this._setSubscription(s,{...c,state:"pending"}),await this._updateSubscriptions()}})();break;case"subscribed":c.callbacks.size===0&&await(async()=>{const{serverSubscriptionId:u,unsubscribeMethod:h}=c;if(this._subscriptionsAutoDisposedByRpc.has(u))this._subscriptionsAutoDisposedByRpc.delete(u);else{this._setSubscription(s,{...c,state:"unsubscribing"}),this._setSubscription(s,{...c,state:"unsubscribing"});try{await this._rpcWebSocket.call(h,[u])}catch(a){if(a instanceof Error&&console.error(`${h} error:`,a.message),!r())return;this._setSubscription(s,{...c,state:"subscribed"}),await this._updateSubscriptions();return}}this._setSubscription(s,{...c,state:"unsubscribed"}),await this._updateSubscriptions()})();break}}))}_handleServerNotification(n,r){const s=this._subscriptionCallbacksByServerSubscriptionId[n];s!==void 0&&s.forEach(c=>{try{c(...r)}catch(u){console.error(u)}})}_wsOnAccountNotification(n){const{result:r,subscription:s}=I(n,Ai);this._handleServerNotification(s,[r.value,r.context])}_makeSubscription(n,r){const s=this._nextClientSubscriptionId++,c=pn([n.method,r],!0),u=this._subscriptionsByHash[c];return u===void 0?this._subscriptionsByHash[c]={...n,args:r,callbacks:new Set([n.callback]),state:"pending"}:u.callbacks.add(n.callback),this._subscriptionHashByClientSubscriptionId[s]=c,this._subscriptionDisposeFunctionsByClientSubscriptionId[s]=async()=>{delete this._subscriptionDisposeFunctionsByClientSubscriptionId[s],delete this._subscriptionHashByClientSubscriptionId[s];const h=this._subscriptionsByHash[c];et(h!==void 0,`Could not find a \`Subscription\` when tearing down client subscription #${s}`),h.callbacks.delete(n.callback),await this._updateSubscriptions()},this._updateSubscriptions(),s}onAccountChange(n,r,s){const c=this._buildArgs([n.toBase58()],s||this._commitment||"finalized","base64");return this._makeSubscription({callback:r,method:"accountSubscribe",unsubscribeMethod:"accountUnsubscribe"},c)}async removeAccountChangeListener(n){await this._unsubscribeClientSubscription(n,"account change")}_wsOnProgramAccountNotification(n){const{result:r,subscription:s}=I(n,_i);this._handleServerNotification(s,[{accountId:r.value.pubkey,accountInfo:r.value.account},r.context])}onProgramAccountChange(n,r,s,c){const u=this._buildArgs([n.toBase58()],s||this._commitment||"finalized","base64",c?{filters:c}:void 0);return this._makeSubscription({callback:r,method:"programSubscribe",unsubscribeMethod:"programUnsubscribe"},u)}async removeProgramAccountChangeListener(n){await this._unsubscribeClientSubscription(n,"program account change")}onLogs(n,r,s){const c=this._buildArgs([typeof n=="object"?{mentions:[n.toString()]}:n],s||this._commitment||"finalized");return this._makeSubscription({callback:r,method:"logsSubscribe",unsubscribeMethod:"logsUnsubscribe"},c)}async removeOnLogsListener(n){await this._unsubscribeClientSubscription(n,"logs")}_wsOnLogsNotification(n){const{result:r,subscription:s}=I(n,ss);this._handleServerNotification(s,[r.value,r.context])}_wsOnSlotNotification(n){const{result:r,subscription:s}=I(n,Ci);this._handleServerNotification(s,[r])}onSlotChange(n){return this._makeSubscription({callback:n,method:"slotSubscribe",unsubscribeMethod:"slotUnsubscribe"},[])}async removeSlotChangeListener(n){await this._unsubscribeClientSubscription(n,"slot change")}_wsOnSlotUpdatesNotification(n){const{result:r,subscription:s}=I(n,Li);this._handleServerNotification(s,[r])}onSlotUpdate(n){return this._makeSubscription({callback:n,method:"slotsUpdatesSubscribe",unsubscribeMethod:"slotsUpdatesUnsubscribe"},[])}async removeSlotUpdateListener(n){await this._unsubscribeClientSubscription(n,"slot update")}async _unsubscribeClientSubscription(n,r){const s=this._subscriptionDisposeFunctionsByClientSubscriptionId[n];s?await s():console.warn(`Ignored unsubscribe request because an active subscription with id \`${n}\` for '${r}' events could not be found.`)}_buildArgs(n,r,s,c){const u=r||this._commitment;if(u||s||c){let h={};s&&(h.encoding=s),u&&(h.commitment=u),c&&(h=Object.assign(h,c)),n.push(h)}return n}_buildArgsAtLeastConfirmed(n,r,s,c){const u=r||this._commitment;if(u&&!["confirmed","finalized"].includes(u))throw new Error("Using Connection with default commitment: `"+this._commitment+"`, but method requires at least `confirmed`");return this._buildArgs(n,r,s,c)}_wsOnSignatureNotification(n){const{result:r,subscription:s}=I(n,Fi);r.value!=="receivedSignature"&&this._subscriptionsAutoDisposedByRpc.add(s),this._handleServerNotification(s,r.value==="receivedSignature"?[{type:"received"},r.context]:[{type:"status",result:r.value},r.context])}onSignature(n,r,s){const c=this._buildArgs([n],s||this._commitment||"finalized"),u=this._makeSubscription({callback:(h,a)=>{if(h.type==="status"){r(h.result,a);try{this.removeSignatureListener(u)}catch{}}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},c);return u}onSignatureWithOptions(n,r,s){const{commitment:c,...u}={...s,commitment:s&&s.commitment||this._commitment||"finalized"},h=this._buildArgs([n],c,void 0,u),a=this._makeSubscription({callback:(g,E)=>{r(g,E);try{this.removeSignatureListener(a)}catch{}},method:"signatureSubscribe",unsubscribeMethod:"signatureUnsubscribe"},h);return a}async removeSignatureListener(n){await this._unsubscribeClientSubscription(n,"signature result")}_wsOnRootNotification(n){const{result:r,subscription:s}=I(n,Pi);this._handleServerNotification(s,[r])}onRootChange(n){return this._makeSubscription({callback:n,method:"rootSubscribe",unsubscribeMethod:"rootUnsubscribe"},[])}async removeRootChangeListener(n){await this._unsubscribeClientSubscription(n,"root change")}}class he{constructor(n){this._keypair=void 0,this._keypair=n??ln()}static generate(){return new he(ln())}static fromSecretKey(n,r){if(n.byteLength!==64)throw new Error("bad secret key size");const s=n.slice(32,64);if(!r||!r.skipValidation){const c=n.slice(0,32),u=ze(c);for(let h=0;h<32;h++)if(s[h]!==u[h])throw new Error("provided secretKey is invalid")}return new he({publicKey:s,secretKey:n})}static fromSeed(n){const r=ze(n),s=new Uint8Array(64);return s.set(n),s.set(r,32),new he({publicKey:r,secretKey:s})}get publicKey(){return new O(this._keypair.publicKey)}get secretKey(){return new Uint8Array(this._keypair.secretKey)}}Object.freeze({CreateLookupTable:{index:0,layout:C([P("instruction"),qt("recentSlot"),V("bumpSeed")])},FreezeLookupTable:{index:1,layout:C([P("instruction")])},ExtendLookupTable:{index:2,layout:C([P("instruction"),qt(),at(G(),Ut(P(),-8),"addresses")])},DeactivateLookupTable:{index:3,layout:C([P("instruction")])},CloseLookupTable:{index:4,layout:C([P("instruction")])}});new O("AddressLookupTab1e1111111111111111111111111");Object.freeze({RequestUnits:{index:0,layout:C([V("instruction"),P("units"),P("additionalFee")])},RequestHeapFrame:{index:1,layout:C([V("instruction"),P("bytes")])},SetComputeUnitLimit:{index:2,layout:C([V("instruction"),P("units")])},SetComputeUnitPrice:{index:3,layout:C([V("instruction"),qt("microLamports")])}});new O("ComputeBudget111111111111111111111111111111");C([V("numSignatures"),V("padding"),pt("signatureOffset"),pt("signatureInstructionIndex"),pt("publicKeyOffset"),pt("publicKeyInstructionIndex"),pt("messageDataOffset"),pt("messageDataSize"),pt("messageInstructionIndex")]);new O("Ed25519SigVerify111111111111111111111111111");kn.utils.isValidPrivateKey;kn.getPublicKey;C([V("numSignatures"),pt("signatureOffset"),V("signatureInstructionIndex"),pt("ethAddressOffset"),V("ethAddressInstructionIndex"),pt("messageDataOffset"),pt("messageDataSize"),V("messageInstructionIndex"),Z(20,"ethAddress"),Z(64,"signature"),V("recoveryId")]);new O("KeccakSecp256k11111111111111111111111111111");new O("StakeConfig11111111111111111111111111111111");class En{constructor(n,r,s){this.unixTimestamp=void 0,this.epoch=void 0,this.custodian=void 0,this.unixTimestamp=n,this.epoch=r,this.custodian=s}}En.default=new En(0,0,O.default);Object.freeze({Initialize:{index:0,layout:C([P("instruction"),Er(),Ir()])},Authorize:{index:1,layout:C([P("instruction"),G("newAuthorized"),P("stakeAuthorizationType")])},Delegate:{index:2,layout:C([P("instruction")])},Split:{index:3,layout:C([P("instruction"),ft("lamports")])},Withdraw:{index:4,layout:C([P("instruction"),ft("lamports")])},Deactivate:{index:5,layout:C([P("instruction")])},Merge:{index:7,layout:C([P("instruction")])},AuthorizeWithSeed:{index:8,layout:C([P("instruction"),G("newAuthorized"),P("stakeAuthorizationType"),Ot("authoritySeed"),G("authorityOwner")])}});new O("Stake11111111111111111111111111111111111111");Object.freeze({InitializeAccount:{index:0,layout:C([P("instruction"),Sr()])},Authorize:{index:1,layout:C([P("instruction"),G("newAuthorized"),P("voteAuthorizationType")])},Withdraw:{index:3,layout:C([P("instruction"),ft("lamports")])},AuthorizeWithSeed:{index:10,layout:C([P("instruction"),xr()])}});new O("Vote111111111111111111111111111111111111111");new O("Va1idator1nfo111111111111111111111111111111");w({name:B(),website:D(B()),details:D(B()),keybaseUsername:D(B())});new O("Vote111111111111111111111111111111111111111");C([G("nodePubkey"),G("authorizedWithdrawer"),V("commission"),st(),at(C([st("slot"),P("confirmationCount")]),Ut(P(),-8),"votes"),V("rootSlotValid"),st("rootSlot"),st(),at(C([st("epoch"),G("authorizedVoter")]),Ut(P(),-8),"authorizedVoters"),C([at(C([G("authorizedPubkey"),st("epochOfLastAuthorizedSwitch"),st("targetEpoch")]),32,"buf"),st("idx"),V("isEmpty")],"priorVoters"),st(),at(C([st("epoch"),st("credits"),st("prevCredits")]),Ut(P(),-8),"epochCredits"),C([st("slot"),st("timestamp")],"lastTimestamp")]);const In={http:{devnet:"http://api.devnet.solana.com",testnet:"http://api.testnet.solana.com","mainnet-beta":"http://api.mainnet-beta.solana.com/"},https:{devnet:"https://api.devnet.solana.com",testnet:"https://api.testnet.solana.com","mainnet-beta":"https://api.mainnet-beta.solana.com/"}};function Bs(d,n){const r=n===!1?"http":"https";if(!d)return In[r].devnet;const s=In[r][d];if(!s)throw new Error(`Unknown ${r} cluster: ${d}`);return s}export{bs as C,he as K,kt as T,Bs as c};
