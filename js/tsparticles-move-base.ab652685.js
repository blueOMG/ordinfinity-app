import{g as M,I as g,c as r,k as z,B as f,l}from"./tsparticles-engine.e4b9023d.js";function F(n){const o=n.initialPosition,{dx:i,dy:e}=M(o,n.position),t=Math.abs(i),a=Math.abs(e),{maxDistance:s}=n.retina,c=s.horizontal,v=s.vertical;if(!(!c&&!v)){if((c&&t>=c||v&&a>=v)&&!n.misplaced)n.misplaced=!!c&&t>c||!!v&&a>v,c&&(n.velocity.x=n.velocity.y/2-n.velocity.x),v&&(n.velocity.y=n.velocity.x/2-n.velocity.y);else if((!c||t<c)&&(!v||a<v)&&n.misplaced)n.misplaced=!1;else if(n.misplaced){const y=n.position,d=n.velocity;c&&(y.x<o.x&&d.x<0||y.x>o.x&&d.x>0)&&(d.x*=-g()),v&&(y.y<o.y&&d.y<0||y.y>o.y&&d.y>0)&&(d.y*=-g())}}}function w(n,o,i,e,t,a){P(n,a);const s=n.gravity,c=s!=null&&s.enable&&s.inverse?-1:1;t&&i&&(n.velocity.x+=t*a.factor/(60*i)),s!=null&&s.enable&&i&&(n.velocity.y+=c*(s.acceleration*a.factor)/(60*i));const v=n.moveDecay;n.velocity.multTo(v);const y=n.velocity.mult(i);s!=null&&s.enable&&e>0&&(!s.inverse&&y.y>=0&&y.y>=e||s.inverse&&y.y<=0&&y.y<=-e)&&(y.y=c*e,i&&(n.velocity.y=y.y/i));const d=n.options.zIndex,u=(1-n.zIndexFactor)**d.velocityRate;y.multTo(u);const{position:x}=n;x.addTo(y),o.vibrate&&(x.x+=Math.sin(x.x*Math.cos(x.y)),x.y+=Math.cos(x.y*Math.sin(x.x)))}function D(n,o){const i=n.container;if(!n.spin)return;const e={x:n.spin.direction==="clockwise"?Math.cos:Math.sin,y:n.spin.direction==="clockwise"?Math.sin:Math.cos};n.position.x=n.spin.center.x+n.spin.radius*e.x(n.spin.angle),n.position.y=n.spin.center.y+n.spin.radius*e.y(n.spin.angle),n.spin.radius+=n.spin.acceleration;const t=Math.max(i.canvas.size.width,i.canvas.size.height);n.spin.radius>t/2?(n.spin.radius=t/2,n.spin.acceleration*=-1):n.spin.radius<0&&(n.spin.radius=0,n.spin.acceleration*=-1),n.spin.angle+=o/100*(1-n.spin.radius/t)}function P(n,o){var s;const i=n.options,e=i.move.path;if(!e.enable)return;if(n.lastPathTime<=n.pathDelay){n.lastPathTime+=o.value;return}const a=(s=n.pathGenerator)==null?void 0:s.generate(n,o);a&&n.velocity.addTo(a),e.clamp&&(n.velocity.x=r(n.velocity.x,-1,1),n.velocity.y=r(n.velocity.y,-1,1)),n.lastPathTime-=n.pathDelay}function R(n){return n.slow.inRange?n.slow.factor:1}const T=2;class k{constructor(){this._initSpin=o=>{const i=o.container,e=o.options,t=e.move.spin;if(!t.enable)return;const a=t.position??{x:50,y:50},s={x:a.x/100*i.canvas.size.width,y:a.y/100*i.canvas.size.height},c=o.getPosition(),v=z(c,s),y=f(t.acceleration);o.retina.spinAcceleration=y*i.retina.pixelRatio,o.spin={center:s,direction:o.velocity.x>=0?"clockwise":"counter-clockwise",angle:o.velocity.angle,radius:v,acceleration:o.retina.spinAcceleration}}}init(o){const i=o.options,e=i.move.gravity;o.gravity={enable:e.enable,acceleration:f(e.acceleration),inverse:e.inverse},this._initSpin(o)}isEnabled(o){return!o.destroyed&&o.options.move.enable}move(o,i){var h,m;const e=o.options,t=e.move;if(!t.enable)return;const a=o.container,s=a.retina.pixelRatio,c=R(o),v=((h=o.retina).moveSpeed??(h.moveSpeed=f(t.speed)*s))*a.retina.reduceFactor,y=(m=o.retina).moveDrift??(m.moveDrift=f(o.options.move.drift)*s),d=l(e.size.value)*s,u=t.size?o.getRadius()/d:1,x=v*u*c*(i.factor||1)/T,b=o.retina.maxSpeed??a.retina.maxSpeed;t.spin.enable?D(o,x):w(o,t,x,b,y,i),F(o)}}async function A(n){n.addMover("base",()=>new k)}export{A as l};
