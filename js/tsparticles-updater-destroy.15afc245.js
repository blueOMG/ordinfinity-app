import{A as h,K as y,O as g,j as b,F as a,Y as m,o as v,Z as z,B as d,S as O}from"./tsparticles-engine.e4b9023d.js";class x{load(o){o&&(o.bottom!==void 0&&(this.bottom=h(o.bottom)),o.left!==void 0&&(this.left=h(o.left)),o.right!==void 0&&(this.right=h(o.right)),o.top!==void 0&&(this.top=h(o.top)))}}class w extends y{constructor(){super(),this.value=3}}class C extends y{constructor(){super(),this.value={min:4,max:9}}}class S{constructor(){this.count=1,this.factor=new w,this.rate=new C,this.sizeOffset=!0}load(o){o&&(o.color!==void 0&&(this.color=g.create(this.color,o.color)),o.count!==void 0&&(this.count=o.count),this.factor.load(o.factor),this.rate.load(o.rate),this.particles=b(o.particles,t=>a({},t)),o.sizeOffset!==void 0&&(this.sizeOffset=o.sizeOffset),o.colorOffset&&(this.colorOffset=this.colorOffset??{},o.colorOffset.h!==void 0&&(this.colorOffset.h=o.colorOffset.h),o.colorOffset.s!==void 0&&(this.colorOffset.s=o.colorOffset.s),o.colorOffset.l!==void 0&&(this.colorOffset.l=o.colorOffset.l)))}}class B{constructor(){this.bounds=new x,this.mode="none",this.split=new S}load(o){o&&(o.mode&&(this.mode=o.mode),o.bounds&&this.bounds.load(o.bounds),this.split.load(o.split))}}function D(i,o,t,s){const r=t.options.destroy;if(!r)return;const n=r.split,e=z(i,o,t.options),f=m(n.factor),u=t.getFillColor();n.color?e.color.load(n.color):n.colorOffset&&u?e.color.load({value:{hsl:{h:u.h+d(n.colorOffset.h??0),s:u.s+d(n.colorOffset.s??0),l:u.l+d(n.colorOffset.l??0)}}}):e.color.load({value:{hsl:t.getFillColor()}}),e.move.load({center:{x:t.position.x,y:t.position.y,mode:"precise"}}),typeof e.size.value=="number"?e.size.value/=f:(e.size.value.min/=f,e.size.value.max/=f),e.load(s);const p=n.sizeOffset?h(-t.size.value,t.size.value):0,c={x:t.position.x+O(p),y:t.position.y+O(p)};return o.particles.addParticle(c,e,t.group,l=>l.size.value<.5?!1:(l.velocity.length=O(h(t.velocity.length,l.velocity.length)),l.splitCount=(t.splitCount??0)+1,l.unbreakable=!0,setTimeout(()=>{l.unbreakable=!1},500),!0))}function F(i,o,t){const s=t.options.destroy;if(!s)return;const r=s.split;if(r.count>=0&&(t.splitCount===void 0||t.splitCount++>r.count))return;const n=m(r.rate),e=v(r.particles);for(let f=0;f<n;f++)D(i,o,t,e)}class P{constructor(o,t){this.engine=o,this.container=t}init(o){const t=this.container,s=o.options,r=s.destroy;if(!r)return;o.splitCount=0;const n=r.bounds;o.destroyBounds||(o.destroyBounds={});const{bottom:e,left:f,right:u,top:p}=n,{destroyBounds:c}=o,l=t.canvas.size;e&&(c.bottom=d(e)*l.height/100),f&&(c.left=d(f)*l.width/100),u&&(c.right=d(u)*l.width/100),p&&(c.top=d(p)*l.height/100)}isEnabled(o){return!o.destroyed}loadOptions(o,...t){o.destroy||(o.destroy=new B);for(const s of t)o.destroy.load(s==null?void 0:s.destroy)}particleDestroyed(o,t){if(t)return;const s=o.options.destroy;s&&s.mode==="split"&&F(this.engine,this.container,o)}update(o){if(!this.isEnabled(o))return;const t=o.getPosition(),s=o.destroyBounds;s&&(s.bottom!==void 0&&t.y>=s.bottom||s.left!==void 0&&t.x<=s.left||s.right!==void 0&&t.x>=s.right||s.top!==void 0&&t.y<=s.top)&&o.destroy()}}async function V(i){await i.addParticleUpdater("destroy",o=>new P(i,o))}export{V as l};
