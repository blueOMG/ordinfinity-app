var ft={},Nt={},et={};Object.defineProperty(et,"__esModule",{value:!0});et.output=et.exists=et.hash=et.bytes=et.bool=et.number=void 0;function Zt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}et.number=Zt;function Te(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}et.bool=Te;function oe(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}et.bytes=oe;function $e(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Zt(t.outputLen),Zt(t.blockLen)}et.hash=$e;function Ne(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}et.exists=Ne;function Ce(t,e){oe(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}et.output=Ce;const bn={number:Zt,bool:Te,bytes:oe,hash:$e,exists:Ne,output:Ce};et.default=bn;var at={},Dt={};Object.defineProperty(Dt,"__esModule",{value:!0});Dt.crypto=void 0;Dt.crypto=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;(function(t){/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(t,"__esModule",{value:!0}),t.randomBytes=t.wrapXOFConstructorWithOpts=t.wrapConstructorWithOpts=t.wrapConstructor=t.checkOpts=t.Hash=t.concatBytes=t.toBytes=t.utf8ToBytes=t.asyncLoop=t.nextTick=t.hexToBytes=t.bytesToHex=t.isLE=t.rotr=t.createView=t.u32=t.u8=void 0;const e=Dt,n=h=>h instanceof Uint8Array,r=h=>new Uint8Array(h.buffer,h.byteOffset,h.byteLength);t.u8=r;const o=h=>new Uint32Array(h.buffer,h.byteOffset,Math.floor(h.byteLength/4));t.u32=o;const c=h=>new DataView(h.buffer,h.byteOffset,h.byteLength);t.createView=c;const s=(h,y)=>h<<32-y|h>>>y;if(t.rotr=s,t.isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68,!t.isLE)throw new Error("Non little-endian hardware is not supported");const i=Array.from({length:256},(h,y)=>y.toString(16).padStart(2,"0"));function f(h){if(!n(h))throw new Error("Uint8Array expected");let y="";for(let A=0;A<h.length;A++)y+=i[h[A]];return y}t.bytesToHex=f;function u(h){if(typeof h!="string")throw new Error("hex string expected, got "+typeof h);const y=h.length;if(y%2)throw new Error("padded hex string expected, got unpadded hex of length "+y);const A=new Uint8Array(y/2);for(let T=0;T<A.length;T++){const g=T*2,p=h.slice(g,g+2),L=Number.parseInt(p,16);if(Number.isNaN(L)||L<0)throw new Error("Invalid byte sequence");A[T]=L}return A}t.hexToBytes=u;const a=async()=>{};t.nextTick=a;async function l(h,y,A){let T=Date.now();for(let g=0;g<h;g++){A(g);const p=Date.now()-T;p>=0&&p<y||(await(0,t.nextTick)(),T+=p)}}t.asyncLoop=l;function E(h){if(typeof h!="string")throw new Error(`utf8ToBytes expected string, got ${typeof h}`);return new Uint8Array(new TextEncoder().encode(h))}t.utf8ToBytes=E;function v(h){if(typeof h=="string"&&(h=E(h)),!n(h))throw new Error(`expected Uint8Array, got ${typeof h}`);return h}t.toBytes=v;function I(...h){const y=new Uint8Array(h.reduce((T,g)=>T+g.length,0));let A=0;return h.forEach(T=>{if(!n(T))throw new Error("Uint8Array expected");y.set(T,A),A+=T.length}),y}t.concatBytes=I;class d{clone(){return this._cloneInto()}}t.Hash=d;const w=h=>Object.prototype.toString.call(h)==="[object Object]"&&h.constructor===Object;function B(h,y){if(y!==void 0&&(typeof y!="object"||!w(y)))throw new Error("Options should be object or undefined");return Object.assign(h,y)}t.checkOpts=B;function k(h){const y=T=>h().update(v(T)).digest(),A=h();return y.outputLen=A.outputLen,y.blockLen=A.blockLen,y.create=()=>h(),y}t.wrapConstructor=k;function S(h){const y=(T,g)=>h(g).update(v(T)).digest(),A=h({});return y.outputLen=A.outputLen,y.blockLen=A.blockLen,y.create=T=>h(T),y}t.wrapConstructorWithOpts=S;function $(h){const y=(T,g)=>h(g).update(v(T)).digest(),A=h({});return y.outputLen=A.outputLen,y.blockLen=A.blockLen,y.create=T=>h(T),y}t.wrapXOFConstructorWithOpts=$;function H(h=32){if(e.crypto&&typeof e.crypto.getRandomValues=="function")return e.crypto.getRandomValues(new Uint8Array(h));throw new Error("crypto.getRandomValues must be defined")}t.randomBytes=H})(at);Object.defineProperty(Nt,"__esModule",{value:!0});Nt.SHA2=void 0;const Wt=et,Ot=at;function wn(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const o=BigInt(32),c=BigInt(4294967295),s=Number(n>>o&c),i=Number(n&c),f=r?4:0,u=r?0:4;t.setUint32(e+f,s,r),t.setUint32(e+u,i,r)}class gn extends Ot.Hash{constructor(e,n,r,o){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=(0,Ot.createView)(this.buffer)}update(e){Wt.default.exists(this);const{view:n,buffer:r,blockLen:o}=this;e=(0,Ot.toBytes)(e);const c=e.length;for(let s=0;s<c;){const i=Math.min(o-this.pos,c-s);if(i===o){const f=(0,Ot.createView)(e);for(;o<=c-s;s+=o)this.process(f,s);continue}r.set(e.subarray(s,s+i),this.pos),this.pos+=i,s+=i,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Wt.default.exists(this),Wt.default.output(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:c}=this;let{pos:s}=this;n[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(r,0),s=0);for(let l=s;l<o;l++)n[l]=0;wn(r,o-8,BigInt(this.length*8),c),this.process(r,0);const i=(0,Ot.createView)(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=f/4,a=this.get();if(u>a.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<u;l++)i.setUint32(4*l,a[l],c)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:c,destroyed:s,pos:i}=this;return e.length=o,e.pos=i,e.finished=c,e.destroyed=s,o%n&&e.buffer.set(r),e}}Nt.SHA2=gn;var Re={};(function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.add=t.toBig=t.split=t.fromBig=void 0;const e=BigInt(2**32-1),n=BigInt(32);function r(g,p=!1){return p?{h:Number(g&e),l:Number(g>>n&e)}:{h:Number(g>>n&e)|0,l:Number(g&e)|0}}t.fromBig=r;function o(g,p=!1){let L=new Uint32Array(g.length),j=new Uint32Array(g.length);for(let z=0;z<g.length;z++){const{h:x,l:_}=r(g[z],p);[L[z],j[z]]=[x,_]}return[L,j]}t.split=o;const c=(g,p)=>BigInt(g>>>0)<<n|BigInt(p>>>0);t.toBig=c;const s=(g,p,L)=>g>>>L,i=(g,p,L)=>g<<32-L|p>>>L,f=(g,p,L)=>g>>>L|p<<32-L,u=(g,p,L)=>g<<32-L|p>>>L,a=(g,p,L)=>g<<64-L|p>>>L-32,l=(g,p,L)=>g>>>L-32|p<<64-L,E=(g,p)=>p,v=(g,p)=>g,I=(g,p,L)=>g<<L|p>>>32-L,d=(g,p,L)=>p<<L|g>>>32-L,w=(g,p,L)=>p<<L-32|g>>>64-L,B=(g,p,L)=>g<<L-32|p>>>64-L;function k(g,p,L,j){const z=(p>>>0)+(j>>>0);return{h:g+L+(z/2**32|0)|0,l:z|0}}t.add=k;const S=(g,p,L)=>(g>>>0)+(p>>>0)+(L>>>0),$=(g,p,L,j)=>p+L+j+(g/2**32|0)|0,H=(g,p,L,j)=>(g>>>0)+(p>>>0)+(L>>>0)+(j>>>0),h=(g,p,L,j,z)=>p+L+j+z+(g/2**32|0)|0,y=(g,p,L,j,z)=>(g>>>0)+(p>>>0)+(L>>>0)+(j>>>0)+(z>>>0),A=(g,p,L,j,z,x)=>p+L+j+z+x+(g/2**32|0)|0,T={fromBig:r,split:o,toBig:t.toBig,shrSH:s,shrSL:i,rotrSH:f,rotrSL:u,rotrBH:a,rotrBL:l,rotr32H:E,rotr32L:v,rotlSH:I,rotlSL:d,rotlBH:w,rotlBL:B,add:k,add3L:S,add3H:$,add4L:H,add4H:h,add5H:A,add5L:y};t.default=T})(Re);Object.defineProperty(ft,"__esModule",{value:!0});ft.sha384=ft.sha512_256=ft.sha512_224=ie=ft.sha512=ft.SHA512=void 0;const yn=Nt,C=Re,Vt=at,[pn,xn]=C.default.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))),dt=new Uint32Array(80),bt=new Uint32Array(80);class Ct extends yn.SHA2{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:n,Bh:r,Bl:o,Ch:c,Cl:s,Dh:i,Dl:f,Eh:u,El:a,Fh:l,Fl:E,Gh:v,Gl:I,Hh:d,Hl:w}=this;return[e,n,r,o,c,s,i,f,u,a,l,E,v,I,d,w]}set(e,n,r,o,c,s,i,f,u,a,l,E,v,I,d,w){this.Ah=e|0,this.Al=n|0,this.Bh=r|0,this.Bl=o|0,this.Ch=c|0,this.Cl=s|0,this.Dh=i|0,this.Dl=f|0,this.Eh=u|0,this.El=a|0,this.Fh=l|0,this.Fl=E|0,this.Gh=v|0,this.Gl=I|0,this.Hh=d|0,this.Hl=w|0}process(e,n){for(let S=0;S<16;S++,n+=4)dt[S]=e.getUint32(n),bt[S]=e.getUint32(n+=4);for(let S=16;S<80;S++){const $=dt[S-15]|0,H=bt[S-15]|0,h=C.default.rotrSH($,H,1)^C.default.rotrSH($,H,8)^C.default.shrSH($,H,7),y=C.default.rotrSL($,H,1)^C.default.rotrSL($,H,8)^C.default.shrSL($,H,7),A=dt[S-2]|0,T=bt[S-2]|0,g=C.default.rotrSH(A,T,19)^C.default.rotrBH(A,T,61)^C.default.shrSH(A,T,6),p=C.default.rotrSL(A,T,19)^C.default.rotrBL(A,T,61)^C.default.shrSL(A,T,6),L=C.default.add4L(y,p,bt[S-7],bt[S-16]),j=C.default.add4H(L,h,g,dt[S-7],dt[S-16]);dt[S]=j|0,bt[S]=L|0}let{Ah:r,Al:o,Bh:c,Bl:s,Ch:i,Cl:f,Dh:u,Dl:a,Eh:l,El:E,Fh:v,Fl:I,Gh:d,Gl:w,Hh:B,Hl:k}=this;for(let S=0;S<80;S++){const $=C.default.rotrSH(l,E,14)^C.default.rotrSH(l,E,18)^C.default.rotrBH(l,E,41),H=C.default.rotrSL(l,E,14)^C.default.rotrSL(l,E,18)^C.default.rotrBL(l,E,41),h=l&v^~l&d,y=E&I^~E&w,A=C.default.add5L(k,H,y,xn[S],bt[S]),T=C.default.add5H(A,B,$,h,pn[S],dt[S]),g=A|0,p=C.default.rotrSH(r,o,28)^C.default.rotrBH(r,o,34)^C.default.rotrBH(r,o,39),L=C.default.rotrSL(r,o,28)^C.default.rotrBL(r,o,34)^C.default.rotrBL(r,o,39),j=r&c^r&i^c&i,z=o&s^o&f^s&f;B=d|0,k=w|0,d=v|0,w=I|0,v=l|0,I=E|0,{h:l,l:E}=C.default.add(u|0,a|0,T|0,g|0),u=i|0,a=f|0,i=c|0,f=s|0,c=r|0,s=o|0;const x=C.default.add3L(g,L,z);r=C.default.add3H(x,T,p,j),o=x|0}({h:r,l:o}=C.default.add(this.Ah|0,this.Al|0,r|0,o|0)),{h:c,l:s}=C.default.add(this.Bh|0,this.Bl|0,c|0,s|0),{h:i,l:f}=C.default.add(this.Ch|0,this.Cl|0,i|0,f|0),{h:u,l:a}=C.default.add(this.Dh|0,this.Dl|0,u|0,a|0),{h:l,l:E}=C.default.add(this.Eh|0,this.El|0,l|0,E|0),{h:v,l:I}=C.default.add(this.Fh|0,this.Fl|0,v|0,I|0),{h:d,l:w}=C.default.add(this.Gh|0,this.Gl|0,d|0,w|0),{h:B,l:k}=C.default.add(this.Hh|0,this.Hl|0,B|0,k|0),this.set(r,o,c,s,i,f,u,a,l,E,v,I,d,w,B,k)}roundClean(){dt.fill(0),bt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}ft.SHA512=Ct;class Bn extends Ct{constructor(){super(),this.Ah=-1942145080,this.Al=424955298,this.Bh=1944164710,this.Bl=-1982016298,this.Ch=502970286,this.Cl=855612546,this.Dh=1738396948,this.Dl=1479516111,this.Eh=258812777,this.El=2077511080,this.Fh=2011393907,this.Fl=79989058,this.Gh=1067287976,this.Gl=1780299464,this.Hh=286451373,this.Hl=-1848208735,this.outputLen=28}}class En extends Ct{constructor(){super(),this.Ah=573645204,this.Al=-64227540,this.Bh=-1621794909,this.Bl=-934517566,this.Ch=596883563,this.Cl=1867755857,this.Dh=-1774684391,this.Dl=1497426621,this.Eh=-1775747358,this.El=-1467023389,this.Fh=-1101128155,this.Fl=1401305490,this.Gh=721525244,this.Gl=746961066,this.Hh=246885852,this.Hl=-2117784414,this.outputLen=32}}class mn extends Ct{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}var ie=ft.sha512=(0,Vt.wrapConstructor)(()=>new Ct);ft.sha512_224=(0,Vt.wrapConstructor)(()=>new Bn);ft.sha512_256=(0,Vt.wrapConstructor)(()=>new En);ft.sha384=(0,Vt.wrapConstructor)(()=>new mn);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qe=BigInt(0),zt=BigInt(1),An=BigInt(2),Gt=t=>t instanceof Uint8Array,In=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function mt(t){if(!Gt(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=In[t[n]];return e}function je(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function ce(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function Lt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const o=r*2,c=t.slice(o,o+2),s=Number.parseInt(c,16);if(Number.isNaN(s)||s<0)throw new Error("Invalid byte sequence");n[r]=s}return n}function Et(t){return ce(mt(t))}function It(t){if(!Gt(t))throw new Error("Uint8Array expected");return ce(mt(Uint8Array.from(t).reverse()))}function St(t,e){return Lt(t.toString(16).padStart(e*2,"0"))}function Ft(t,e){return St(t,e).reverse()}function Sn(t){return Lt(je(t))}function K(t,e,n){let r;if(typeof e=="string")try{r=Lt(e)}catch(c){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${c}`)}else if(Gt(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${t} expected ${n} bytes, got ${o}`);return r}function At(...t){const e=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let n=0;return t.forEach(r=>{if(!Gt(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function Hn(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function Ln(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function vn(t){let e;for(e=0;t>qe;t>>=zt,e+=1);return e}function _n(t,e){return t>>BigInt(e)&zt}const On=(t,e,n)=>t|(n?zt:qe)<<BigInt(e),fe=t=>(An<<BigInt(t-1))-zt,Xt=t=>new Uint8Array(t),me=t=>Uint8Array.from(t);function Ze(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=Xt(t),o=Xt(t),c=0;const s=()=>{r.fill(1),o.fill(0),c=0},i=(...l)=>n(o,r,...l),f=(l=Xt())=>{o=i(me([0]),l),r=i(),l.length!==0&&(o=i(me([1]),l),r=i())},u=()=>{if(c++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const E=[];for(;l<e;){r=i();const v=r.slice();E.push(v),l+=r.length}return At(...E)};return(l,E)=>{s(),f(l);let v;for(;!(v=E(u()));)f();return s(),v}}const kn={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function vt(t,e,n={}){const r=(o,c,s)=>{const i=kn[c];if(typeof i!="function")throw new Error(`Invalid validator "${c}", expected function`);const f=t[o];if(!(s&&f===void 0)&&!i(f,t))throw new Error(`Invalid param ${String(o)}=${f} (${typeof f}), expected ${c}`)};for(const[o,c]of Object.entries(e))r(o,c,!1);for(const[o,c]of Object.entries(n))r(o,c,!0);return t}const Un=Object.freeze(Object.defineProperty({__proto__:null,bitGet:_n,bitLen:vn,bitMask:fe,bitSet:On,bytesToHex:mt,bytesToNumberBE:Et,bytesToNumberLE:It,concatBytes:At,createHmacDrbg:Ze,ensureBytes:K,equalBytes:Hn,hexToBytes:Lt,hexToNumber:ce,numberToBytesBE:St,numberToBytesLE:Ft,numberToHexUnpadded:je,numberToVarBytesBE:Sn,utf8ToBytes:Ln,validateObject:vt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Q=BigInt(0),Y=BigInt(1),xt=BigInt(2),Tn=BigInt(3),Qt=BigInt(4),Ae=BigInt(5),Ie=BigInt(8);BigInt(9);BigInt(16);function G(t,e){const n=t%e;return n>=Q?n:e+n}function $n(t,e,n){if(n<=Q||e<Q)throw new Error("Expected power/modulo > 0");if(n===Y)return Q;let r=Y;for(;e>Q;)e&Y&&(r=r*t%n),t=t*t%n,e>>=Y;return r}function M(t,e,n){let r=t;for(;e-- >Q;)r*=r,r%=n;return r}function Jt(t,e){if(t===Q||e<=Q)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=G(t,e),r=e,o=Q,c=Y;for(;n!==Q;){const i=r/n,f=r%n,u=o-c*i;r=n,n=f,o=c,c=u}if(r!==Y)throw new Error("invert: does not exist");return G(o,e)}function Nn(t){const e=(t-Y)/xt;let n,r,o;for(n=t-Y,r=0;n%xt===Q;n/=xt,r++);for(o=xt;o<t&&$n(o,e,t)!==t-Y;o++);if(r===1){const s=(t+Y)/Qt;return function(f,u){const a=f.pow(u,s);if(!f.eql(f.sqr(a),u))throw new Error("Cannot find square root");return a}}const c=(n+Y)/xt;return function(i,f){if(i.pow(f,e)===i.neg(i.ONE))throw new Error("Cannot find square root");let u=r,a=i.pow(i.mul(i.ONE,o),n),l=i.pow(f,c),E=i.pow(f,n);for(;!i.eql(E,i.ONE);){if(i.eql(E,i.ZERO))return i.ZERO;let v=1;for(let d=i.sqr(E);v<u&&!i.eql(d,i.ONE);v++)d=i.sqr(d);const I=i.pow(a,Y<<BigInt(u-v-1));a=i.sqr(I),l=i.mul(l,I),E=i.mul(E,a),u=v}return l}}function Cn(t){if(t%Qt===Tn){const e=(t+Y)/Qt;return function(r,o){const c=r.pow(o,e);if(!r.eql(r.sqr(c),o))throw new Error("Cannot find square root");return c}}if(t%Ie===Ae){const e=(t-Ae)/Ie;return function(r,o){const c=r.mul(o,xt),s=r.pow(c,e),i=r.mul(o,s),f=r.mul(r.mul(i,xt),s),u=r.mul(i,r.sub(f,r.ONE));if(!r.eql(r.sqr(u),o))throw new Error("Cannot find square root");return u}}return Nn(t)}const Rn=(t,e)=>(G(t,e)&Y)===Y,qn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function jn(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=qn.reduce((r,o)=>(r[o]="function",r),e);return vt(t,n)}function Zn(t,e,n){if(n<Q)throw new Error("Expected power > 0");if(n===Q)return t.ONE;if(n===Y)return e;let r=t.ONE,o=e;for(;n>Q;)n&Y&&(r=t.mul(r,o)),o=t.sqr(o),n>>=Y;return r}function Fn(t,e){const n=new Array(e.length),r=e.reduce((c,s,i)=>t.is0(s)?c:(n[i]=c,t.mul(c,s)),t.ONE),o=t.inv(r);return e.reduceRight((c,s,i)=>t.is0(s)?c:(n[i]=t.mul(c,n[i]),t.mul(c,s)),o),n}function ae(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Fe(t,e,n=!1,r={}){if(t<=Q)throw new Error(`Expected Fp ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:c}=ae(t,e);if(c>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=Cn(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:c,MASK:fe(o),ZERO:Q,ONE:Y,create:f=>G(f,t),isValid:f=>{if(typeof f!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof f}`);return Q<=f&&f<t},is0:f=>f===Q,isOdd:f=>(f&Y)===Y,neg:f=>G(-f,t),eql:(f,u)=>f===u,sqr:f=>G(f*f,t),add:(f,u)=>G(f+u,t),sub:(f,u)=>G(f-u,t),mul:(f,u)=>G(f*u,t),pow:(f,u)=>Zn(i,f,u),div:(f,u)=>G(f*Jt(u,t),t),sqrN:f=>f*f,addN:(f,u)=>f+u,subN:(f,u)=>f-u,mulN:(f,u)=>f*u,inv:f=>Jt(f,t),sqrt:r.sqrt||(f=>s(i,f)),invertBatch:f=>Fn(i,f),cmov:(f,u,a)=>a?u:f,toBytes:f=>n?Ft(f,c):St(f,c),fromBytes:f=>{if(f.length!==c)throw new Error(`Fp.fromBytes: expected ${c}, got ${f.length}`);return n?It(f):Et(f)}});return Object.freeze(i)}function Dn(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?t.neg(n):n}function Vn(t,e,n=!1){t=K("privateHash",t);const r=t.length,o=ae(e).nByteLength+8;if(o<24||r<o||r>1024)throw new Error(`hashToPrivateScalar: expected ${o}-1024 bytes of input, got ${r}`);const c=n?It(t):Et(t);return G(c,e-Y)+Y}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const zn=BigInt(0),Kt=BigInt(1);function De(t,e){const n=(o,c)=>{const s=c.negate();return o?s:c},r=o=>{const c=Math.ceil(e/o)+1,s=2**(o-1);return{windows:c,windowSize:s}};return{constTimeNegate:n,unsafeLadder(o,c){let s=t.ZERO,i=o;for(;c>zn;)c&Kt&&(s=s.add(i)),i=i.double(),c>>=Kt;return s},precomputeWindow(o,c){const{windows:s,windowSize:i}=r(c),f=[];let u=o,a=u;for(let l=0;l<s;l++){a=u,f.push(a);for(let E=1;E<i;E++)a=a.add(u),f.push(a);u=a.double()}return f},wNAF(o,c,s){const{windows:i,windowSize:f}=r(o);let u=t.ZERO,a=t.BASE;const l=BigInt(2**o-1),E=2**o,v=BigInt(o);for(let I=0;I<i;I++){const d=I*f;let w=Number(s&l);s>>=v,w>f&&(w-=E,s+=Kt);const B=d,k=d+Math.abs(w)-1,S=I%2!==0,$=w<0;w===0?a=a.add(n(S,c[B])):u=u.add(n($,c[k]))}return{p:u,f:a}},wNAFCached(o,c,s,i){const f=o._WINDOW_SIZE||1;let u=c.get(o);return u||(u=this.precomputeWindow(o,f),f!==1&&c.set(o,i(u))),this.wNAF(f,u,s)}}}function ue(t){return jn(t.Fp),vt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ae(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ct=BigInt(0),rt=BigInt(1),Rt=BigInt(2),Gn=BigInt(8),Yn={zip215:!0};function Pn(t){const e=ue(t);return vt(t,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...e})}function le(t){const e=Pn(t),{Fp:n,n:r,prehash:o,hash:c,randomBytes:s,nByteLength:i,h:f}=e,u=Rt<<BigInt(i*8)-rt,a=n.create,l=e.uvRatio||((m,b)=>{try{return{isValid:!0,value:n.sqrt(m*n.inv(b))}}catch{return{isValid:!1,value:ct}}}),E=e.adjustScalarBytes||(m=>m),v=e.domain||((m,b,O)=>{if(b.length||O)throw new Error("Contexts/pre-hash are not supported");return m}),I=m=>typeof m=="bigint"&&ct<m,d=(m,b)=>I(m)&&I(b)&&m<b,w=m=>m===ct||d(m,u);function B(m,b){if(d(m,b))return m;throw new Error(`Expected valid scalar < ${b}, got ${typeof m} ${m}`)}function k(m){return m===ct?m:B(m,r)}const S=new Map;function $(m){if(!(m instanceof H))throw new Error("ExtendedPoint expected")}class H{constructor(b,O,U,N){if(this.ex=b,this.ey=O,this.ez=U,this.et=N,!w(b))throw new Error("x required");if(!w(O))throw new Error("y required");if(!w(U))throw new Error("z required");if(!w(N))throw new Error("t required")}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(b){if(b instanceof H)throw new Error("extended point not allowed");const{x:O,y:U}=b||{};if(!w(O)||!w(U))throw new Error("invalid affine point");return new H(O,U,rt,a(O*U))}static normalizeZ(b){const O=n.invertBatch(b.map(U=>U.ez));return b.map((U,N)=>U.toAffine(O[N])).map(H.fromAffine)}_setWindowSize(b){this._WINDOW_SIZE=b,S.delete(this)}assertValidity(){const{a:b,d:O}=e;if(this.is0())throw new Error("bad point: ZERO");const{ex:U,ey:N,ez:q,et:Z}=this,V=a(U*U),F=a(N*N),D=a(q*q),X=a(D*D),P=a(V*b),J=a(D*a(P+F)),tt=a(X+a(O*a(V*F)));if(J!==tt)throw new Error("bad point: equation left != right (1)");const nt=a(U*N),W=a(q*Z);if(nt!==W)throw new Error("bad point: equation left != right (2)")}equals(b){$(b);const{ex:O,ey:U,ez:N}=this,{ex:q,ey:Z,ez:V}=b,F=a(O*V),D=a(q*N),X=a(U*V),P=a(Z*N);return F===D&&X===P}is0(){return this.equals(H.ZERO)}negate(){return new H(a(-this.ex),this.ey,this.ez,a(-this.et))}double(){const{a:b}=e,{ex:O,ey:U,ez:N}=this,q=a(O*O),Z=a(U*U),V=a(Rt*a(N*N)),F=a(b*q),D=O+U,X=a(a(D*D)-q-Z),P=F+Z,J=P-V,tt=F-Z,nt=a(X*J),W=a(P*tt),it=a(X*tt),pt=a(J*P);return new H(nt,W,pt,it)}add(b){$(b);const{a:O,d:U}=e,{ex:N,ey:q,ez:Z,et:V}=this,{ex:F,ey:D,ez:X,et:P}=b;if(O===BigInt(-1)){const we=a((q-N)*(D+F)),ge=a((q+N)*(D-F)),Mt=a(ge-we);if(Mt===ct)return this.double();const ye=a(Z*Rt*P),pe=a(V*Rt*X),xe=pe+ye,Be=ge+we,Ee=pe-ye,un=a(xe*Mt),ln=a(Be*Ee),hn=a(xe*Ee),dn=a(Mt*Be);return new H(un,ln,dn,hn)}const J=a(N*F),tt=a(q*D),nt=a(V*U*P),W=a(Z*X),it=a((N+q)*(F+D)-J-tt),pt=W-nt,_t=W+nt,be=a(tt-O*J),on=a(it*pt),cn=a(_t*be),fn=a(it*be),an=a(pt*_t);return new H(on,cn,an,fn)}subtract(b){return this.add(b.negate())}wNAF(b){return A.wNAFCached(this,S,b,H.normalizeZ)}multiply(b){const{p:O,f:U}=this.wNAF(B(b,r));return H.normalizeZ([O,U])[0]}multiplyUnsafe(b){let O=k(b);return O===ct?y:this.equals(y)||O===rt?this:this.equals(h)?this.wNAF(O).p:A.unsafeLadder(this,O)}isSmallOrder(){return this.multiplyUnsafe(f).is0()}isTorsionFree(){return A.unsafeLadder(this,r).is0()}toAffine(b){const{ex:O,ey:U,ez:N}=this,q=this.is0();b==null&&(b=q?Gn:n.inv(N));const Z=a(O*b),V=a(U*b),F=a(N*b);if(q)return{x:ct,y:rt};if(F!==rt)throw new Error("invZ was invalid");return{x:Z,y:V}}clearCofactor(){const{h:b}=e;return b===rt?this:this.multiplyUnsafe(b)}static fromHex(b,O=!1){const{d:U,a:N}=e,q=n.BYTES;b=K("pointHex",b,q);const Z=b.slice(),V=b[q-1];Z[q-1]=V&-129;const F=It(Z);F===ct||(O?B(F,u):B(F,n.ORDER));const D=a(F*F),X=a(D-rt),P=a(U*D-N);let{isValid:J,value:tt}=l(X,P);if(!J)throw new Error("Point.fromHex: invalid y coordinate");const nt=(tt&rt)===rt,W=(V&128)!==0;if(!O&&tt===ct&&W)throw new Error("Point.fromHex: x=0 and x_0=1");return W!==nt&&(tt=a(-tt)),H.fromAffine({x:tt,y:F})}static fromPrivateKey(b){return p(b).point}toRawBytes(){const{x:b,y:O}=this.toAffine(),U=Ft(O,n.BYTES);return U[U.length-1]|=b&rt?128:0,U}toHex(){return mt(this.toRawBytes())}}H.BASE=new H(e.Gx,e.Gy,rt,a(e.Gx*e.Gy)),H.ZERO=new H(ct,rt,rt,ct);const{BASE:h,ZERO:y}=H,A=De(H,i*8);function T(m){return G(m,r)}function g(m){return T(It(m))}function p(m){const b=i;m=K("private key",m,b);const O=K("hashed private key",c(m),2*b),U=E(O.slice(0,b)),N=O.slice(b,2*b),q=g(U),Z=h.multiply(q),V=Z.toRawBytes();return{head:U,prefix:N,scalar:q,point:Z,pointBytes:V}}function L(m){return p(m).pointBytes}function j(m=new Uint8Array,...b){const O=At(...b);return g(c(v(O,K("context",m),!!o)))}function z(m,b,O={}){m=K("message",m),o&&(m=o(m));const{prefix:U,scalar:N,pointBytes:q}=p(b),Z=j(O.context,U,m),V=h.multiply(Z).toRawBytes(),F=j(O.context,V,q,m),D=T(Z+F*N);k(D);const X=At(V,Ft(D,n.BYTES));return K("result",X,i*2)}const x=Yn;function _(m,b,O,U=x){const{context:N,zip215:q}=U,Z=n.BYTES;m=K("signature",m,2*Z),b=K("message",b),o&&(b=o(b));const V=It(m.slice(Z,2*Z));let F,D,X;try{F=H.fromHex(O,q),D=H.fromHex(m.slice(0,Z),q),X=h.multiplyUnsafe(V)}catch{return!1}if(!q&&F.isSmallOrder())return!1;const P=j(N,D.toRawBytes(),F.toRawBytes(),b);return D.add(F.multiplyUnsafe(P)).subtract(X).clearCofactor().equals(H.ZERO)}return h._setWindowSize(8),{CURVE:e,getPublicKey:L,sign:z,verify:_,ExtendedPoint:H,utils:{getExtendedPublicKey:p,randomPrivateKey:()=>s(n.BYTES),precompute(m=8,b=H.BASE){return b._setWindowSize(m),b.multiply(BigInt(3)),b}}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(0);BigInt(1);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const he=BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),Se=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt(0);const Mn=BigInt(1),te=BigInt(2),Wn=BigInt(5),He=BigInt(10),Xn=BigInt(20),Kn=BigInt(40),Le=BigInt(80);function Qn(t){const e=he,r=t*t%e*t%e,o=M(r,te,e)*r%e,c=M(o,Mn,e)*t%e,s=M(c,Wn,e)*c%e,i=M(s,He,e)*s%e,f=M(i,Xn,e)*i%e,u=M(f,Kn,e)*f%e,a=M(u,Le,e)*u%e,l=M(a,Le,e)*u%e,E=M(l,He,e)*s%e;return{pow_p_5_8:M(E,te,e)*t%e,b2:r}}function Jn(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}function tr(t,e){const n=he,r=G(e*e*e,n),o=G(r*r*e,n),c=Qn(t*o).pow_p_5_8;let s=G(t*r*c,n);const i=G(e*s*s,n),f=s,u=G(s*Se,n),a=i===t,l=i===G(-t,n),E=i===G(-t*Se,n);return a&&(s=f),(l||E)&&(s=u),Rn(s,n)&&(s=G(-s,n)),{isValid:a||l,value:s}}const ht=Fe(he,void 0,!0),de={a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),Fp:ht,n:BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),hash:ie,randomBytes:at.randomBytes,adjustScalarBytes:Jn,uvRatio:tr},is=le(de);function Ve(t,e,n){if(e.length>255)throw new Error("Context is too big");return at.concatBytes(at.utf8ToBytes("SigEd25519 no Ed25519 collisions"),new Uint8Array([n?1:0,e.length]),e,t)}le({...de,domain:Ve});le({...de,domain:Ve,prehash:ie});const er=(ht.ORDER+BigInt(3))/BigInt(8);ht.pow(te,er);ht.sqrt(ht.neg(ht.ONE));(ht.ORDER-BigInt(5))/BigInt(8);BigInt(486662);Dn(ht,ht.neg(BigInt(486664)));BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");var Ut={};Object.defineProperty(Ut,"__esModule",{value:!0});Ut.sha224=Ge=Ut.sha256=void 0;const nr=Nt,st=at,rr=(t,e,n)=>t&e^~t&n,sr=(t,e,n)=>t&e^t&n^e&n,or=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),wt=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),gt=new Uint32Array(64);class ze extends nr.SHA2{constructor(){super(64,32,8,!1),this.A=wt[0]|0,this.B=wt[1]|0,this.C=wt[2]|0,this.D=wt[3]|0,this.E=wt[4]|0,this.F=wt[5]|0,this.G=wt[6]|0,this.H=wt[7]|0}get(){const{A:e,B:n,C:r,D:o,E:c,F:s,G:i,H:f}=this;return[e,n,r,o,c,s,i,f]}set(e,n,r,o,c,s,i,f){this.A=e|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=c|0,this.F=s|0,this.G=i|0,this.H=f|0}process(e,n){for(let l=0;l<16;l++,n+=4)gt[l]=e.getUint32(n,!1);for(let l=16;l<64;l++){const E=gt[l-15],v=gt[l-2],I=(0,st.rotr)(E,7)^(0,st.rotr)(E,18)^E>>>3,d=(0,st.rotr)(v,17)^(0,st.rotr)(v,19)^v>>>10;gt[l]=d+gt[l-7]+I+gt[l-16]|0}let{A:r,B:o,C:c,D:s,E:i,F:f,G:u,H:a}=this;for(let l=0;l<64;l++){const E=(0,st.rotr)(i,6)^(0,st.rotr)(i,11)^(0,st.rotr)(i,25),v=a+E+rr(i,f,u)+or[l]+gt[l]|0,d=((0,st.rotr)(r,2)^(0,st.rotr)(r,13)^(0,st.rotr)(r,22))+sr(r,o,c)|0;a=u,u=f,f=i,i=s+v|0,s=c,c=o,o=r,r=v+d|0}r=r+this.A|0,o=o+this.B|0,c=c+this.C|0,s=s+this.D|0,i=i+this.E|0,f=f+this.F|0,u=u+this.G|0,a=a+this.H|0,this.set(r,o,c,s,i,f,u,a)}roundClean(){gt.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class ir extends ze{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}var Ge=Ut.sha256=(0,st.wrapConstructor)(()=>new ze);Ut.sha224=(0,st.wrapConstructor)(()=>new ir);function ee(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function cr(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}function Ye(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function fr(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");ee(t.outputLen),ee(t.blockLen)}function ar(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function ur(t,e){Ye(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const ut={number:ee,bool:cr,bytes:Ye,hash:fr,exists:ar,output:ur},qt=BigInt(2**32-1),ne=BigInt(32);function Pe(t,e=!1){return e?{h:Number(t&qt),l:Number(t>>ne&qt)}:{h:Number(t>>ne&qt)|0,l:Number(t&qt)|0}}function lr(t,e=!1){let n=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:c,l:s}=Pe(t[o],e);[n[o],r[o]]=[c,s]}return[n,r]}const hr=(t,e)=>BigInt(t>>>0)<<ne|BigInt(e>>>0),dr=(t,e,n)=>t>>>n,br=(t,e,n)=>t<<32-n|e>>>n,wr=(t,e,n)=>t>>>n|e<<32-n,gr=(t,e,n)=>t<<32-n|e>>>n,yr=(t,e,n)=>t<<64-n|e>>>n-32,pr=(t,e,n)=>t>>>n-32|e<<64-n,xr=(t,e)=>e,Br=(t,e)=>t,Er=(t,e,n)=>t<<n|e>>>32-n,mr=(t,e,n)=>e<<n|t>>>32-n,Ar=(t,e,n)=>e<<n-32|t>>>64-n,Ir=(t,e,n)=>t<<n-32|e>>>64-n;function Sr(t,e,n,r){const o=(e>>>0)+(r>>>0);return{h:t+n+(o/2**32|0)|0,l:o|0}}const Hr=(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0),Lr=(t,e,n,r)=>e+n+r+(t/2**32|0)|0,vr=(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0),_r=(t,e,n,r,o)=>e+n+r+o+(t/2**32|0)|0,Or=(t,e,n,r,o)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(o>>>0),kr=(t,e,n,r,o,c)=>e+n+r+o+c+(t/2**32|0)|0,Tt={fromBig:Pe,split:lr,toBig:hr,shrSH:dr,shrSL:br,rotrSH:wr,rotrSL:gr,rotrBH:yr,rotrBL:pr,rotr32H:xr,rotr32L:Br,rotlSH:Er,rotlSL:mr,rotlBH:Ar,rotlBL:Ir,add:Sr,add3L:Hr,add3H:Lr,add4L:vr,add4H:_r,add5H:kr,add5L:Or};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ur=t=>t instanceof Uint8Array,Tr=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),$r=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!$r)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Nr(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Yt(t){if(typeof t=="string"&&(t=Nr(t)),!Ur(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}class Me{clone(){return this._cloneInto()}}function Cr(t){const e=r=>t().update(Yt(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function Rr(t){const e=(r,o)=>t(o).update(Yt(r)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>t(r),e}const[We,Xe,Ke]=[[],[],[]],qr=BigInt(0),kt=BigInt(1),jr=BigInt(2),Zr=BigInt(7),Fr=BigInt(256),Dr=BigInt(113);for(let t=0,e=kt,n=1,r=0;t<24;t++){[n,r]=[r,(2*n+3*r)%5],We.push(2*(5*r+n)),Xe.push((t+1)*(t+2)/2%64);let o=qr;for(let c=0;c<7;c++)e=(e<<kt^(e>>Zr)*Dr)%Fr,e&jr&&(o^=kt<<(kt<<BigInt(c))-kt);Ke.push(o)}const[Vr,zr]=Tt.split(Ke,!0),ve=(t,e,n)=>n>32?Tt.rotlBH(t,e,n):Tt.rotlSH(t,e,n),_e=(t,e,n)=>n>32?Tt.rotlBL(t,e,n):Tt.rotlSL(t,e,n);function Gr(t,e=24){const n=new Uint32Array(10);for(let r=24-e;r<24;r++){for(let s=0;s<10;s++)n[s]=t[s]^t[s+10]^t[s+20]^t[s+30]^t[s+40];for(let s=0;s<10;s+=2){const i=(s+8)%10,f=(s+2)%10,u=n[f],a=n[f+1],l=ve(u,a,1)^n[i],E=_e(u,a,1)^n[i+1];for(let v=0;v<50;v+=10)t[s+v]^=l,t[s+v+1]^=E}let o=t[2],c=t[3];for(let s=0;s<24;s++){const i=Xe[s],f=ve(o,c,i),u=_e(o,c,i),a=We[s];o=t[a],c=t[a+1],t[a]=f,t[a+1]=u}for(let s=0;s<50;s+=10){for(let i=0;i<10;i++)n[i]=t[s+i];for(let i=0;i<10;i++)t[s+i]^=~n[(i+2)%10]&n[(i+4)%10]}t[0]^=Vr[r],t[1]^=zr[r]}n.fill(0)}class Pt extends Me{constructor(e,n,r,o=!1,c=24){if(super(),this.blockLen=e,this.suffix=n,this.outputLen=r,this.enableXOF=o,this.rounds=c,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,ut.number(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Tr(this.state)}keccak(){Gr(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){ut.exists(this);const{blockLen:n,state:r}=this;e=Yt(e);const o=e.length;for(let c=0;c<o;){const s=Math.min(n-this.pos,o-c);for(let i=0;i<s;i++)r[this.pos++]^=e[c++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:n,pos:r,blockLen:o}=this;e[r]^=n,n&128&&r===o-1&&this.keccak(),e[o-1]^=128,this.keccak()}writeInto(e){ut.exists(this,!1),ut.bytes(e),this.finish();const n=this.state,{blockLen:r}=this;for(let o=0,c=e.length;o<c;){this.posOut>=r&&this.keccak();const s=Math.min(r-this.posOut,c-o);e.set(n.subarray(this.posOut,this.posOut+s),o),this.posOut+=s,o+=s}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return ut.number(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(ut.output(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:n,suffix:r,outputLen:o,rounds:c,enableXOF:s}=this;return e||(e=new Pt(n,r,o,s,c)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=c,e.suffix=r,e.outputLen=o,e.enableXOF=s,e.destroyed=this.destroyed,e}}const yt=(t,e,n)=>Cr(()=>new Pt(e,t,n));yt(6,144,224/8);yt(6,136,256/8);yt(6,104,384/8);yt(6,72,512/8);yt(1,144,224/8);yt(1,136,256/8);yt(1,104,384/8);yt(1,72,512/8);const Qe=(t,e,n)=>Rr((r={})=>new Pt(e,t,r.dkLen===void 0?n:r.dkLen,!0));Qe(31,168,128/8);Qe(31,136,256/8);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Yr(t){const e=ue(t);vt(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:Pr,hexToBytes:Mr}=Un,Bt={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=Bt;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:Pr(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=Bt,n=typeof t=="string"?Mr(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:o,l:c}=Bt._parseInt(n.subarray(2)),{d:s,l:i}=Bt._parseInt(c);if(i.length)throw new e("Invalid signature: left bytes after parsing");return{r:o,s}},hexFromSig(t){const e=u=>Number.parseInt(u[0],16)&8?"00"+u:u,n=u=>{const a=u.toString(16);return a.length&1?`0${a}`:a},r=e(n(t.s)),o=e(n(t.r)),c=r.length/2,s=o.length/2,i=n(c),f=n(s);return`30${n(s+c+4)}02${f}${o}02${i}${r}`}},lt=BigInt(0),ot=BigInt(1);BigInt(2);const Oe=BigInt(3);BigInt(4);function Wr(t){const e=Yr(t),{Fp:n}=e,r=e.toBytes||((I,d,w)=>{const B=d.toAffine();return At(Uint8Array.from([4]),n.toBytes(B.x),n.toBytes(B.y))}),o=e.fromBytes||(I=>{const d=I.subarray(1),w=n.fromBytes(d.subarray(0,n.BYTES)),B=n.fromBytes(d.subarray(n.BYTES,2*n.BYTES));return{x:w,y:B}});function c(I){const{a:d,b:w}=e,B=n.sqr(I),k=n.mul(B,I);return n.add(n.add(k,n.mul(I,d)),w)}if(!n.eql(n.sqr(e.Gy),c(e.Gx)))throw new Error("bad generator point: equation left != right");function s(I){return typeof I=="bigint"&&lt<I&&I<e.n}function i(I){if(!s(I))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function f(I){const{allowedPrivateKeyLengths:d,nByteLength:w,wrapPrivateKey:B,n:k}=e;if(d&&typeof I!="bigint"){if(I instanceof Uint8Array&&(I=mt(I)),typeof I!="string"||!d.includes(I.length))throw new Error("Invalid key");I=I.padStart(w*2,"0")}let S;try{S=typeof I=="bigint"?I:Et(K("private key",I,w))}catch{throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof I}`)}return B&&(S=G(S,k)),i(S),S}const u=new Map;function a(I){if(!(I instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(d,w,B){if(this.px=d,this.py=w,this.pz=B,d==null||!n.isValid(d))throw new Error("x required");if(w==null||!n.isValid(w))throw new Error("y required");if(B==null||!n.isValid(B))throw new Error("z required")}static fromAffine(d){const{x:w,y:B}=d||{};if(!d||!n.isValid(w)||!n.isValid(B))throw new Error("invalid affine point");if(d instanceof l)throw new Error("projective point not allowed");const k=S=>n.eql(S,n.ZERO);return k(w)&&k(B)?l.ZERO:new l(w,B,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(d){const w=n.invertBatch(d.map(B=>B.pz));return d.map((B,k)=>B.toAffine(w[k])).map(l.fromAffine)}static fromHex(d){const w=l.fromAffine(o(K("pointHex",d)));return w.assertValidity(),w}static fromPrivateKey(d){return l.BASE.multiply(f(d))}_setWindowSize(d){this._WINDOW_SIZE=d,u.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint)return;throw new Error("bad point: ZERO")}const{x:d,y:w}=this.toAffine();if(!n.isValid(d)||!n.isValid(w))throw new Error("bad point: x or y not FE");const B=n.sqr(w),k=c(d);if(!n.eql(B,k))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:d}=this.toAffine();if(n.isOdd)return!n.isOdd(d);throw new Error("Field doesn't support isOdd")}equals(d){a(d);const{px:w,py:B,pz:k}=this,{px:S,py:$,pz:H}=d,h=n.eql(n.mul(w,H),n.mul(S,k)),y=n.eql(n.mul(B,H),n.mul($,k));return h&&y}negate(){return new l(this.px,n.neg(this.py),this.pz)}double(){const{a:d,b:w}=e,B=n.mul(w,Oe),{px:k,py:S,pz:$}=this;let H=n.ZERO,h=n.ZERO,y=n.ZERO,A=n.mul(k,k),T=n.mul(S,S),g=n.mul($,$),p=n.mul(k,S);return p=n.add(p,p),y=n.mul(k,$),y=n.add(y,y),H=n.mul(d,y),h=n.mul(B,g),h=n.add(H,h),H=n.sub(T,h),h=n.add(T,h),h=n.mul(H,h),H=n.mul(p,H),y=n.mul(B,y),g=n.mul(d,g),p=n.sub(A,g),p=n.mul(d,p),p=n.add(p,y),y=n.add(A,A),A=n.add(y,A),A=n.add(A,g),A=n.mul(A,p),h=n.add(h,A),g=n.mul(S,$),g=n.add(g,g),A=n.mul(g,p),H=n.sub(H,A),y=n.mul(g,T),y=n.add(y,y),y=n.add(y,y),new l(H,h,y)}add(d){a(d);const{px:w,py:B,pz:k}=this,{px:S,py:$,pz:H}=d;let h=n.ZERO,y=n.ZERO,A=n.ZERO;const T=e.a,g=n.mul(e.b,Oe);let p=n.mul(w,S),L=n.mul(B,$),j=n.mul(k,H),z=n.add(w,B),x=n.add(S,$);z=n.mul(z,x),x=n.add(p,L),z=n.sub(z,x),x=n.add(w,k);let _=n.add(S,H);return x=n.mul(x,_),_=n.add(p,j),x=n.sub(x,_),_=n.add(B,k),h=n.add($,H),_=n.mul(_,h),h=n.add(L,j),_=n.sub(_,h),A=n.mul(T,x),h=n.mul(g,j),A=n.add(h,A),h=n.sub(L,A),A=n.add(L,A),y=n.mul(h,A),L=n.add(p,p),L=n.add(L,p),j=n.mul(T,j),x=n.mul(g,x),L=n.add(L,j),j=n.sub(p,j),j=n.mul(T,j),x=n.add(x,j),p=n.mul(L,x),y=n.add(y,p),p=n.mul(_,x),h=n.mul(z,h),h=n.sub(h,p),p=n.mul(z,L),A=n.mul(_,A),A=n.add(A,p),new l(h,y,A)}subtract(d){return this.add(d.negate())}is0(){return this.equals(l.ZERO)}wNAF(d){return v.wNAFCached(this,u,d,w=>{const B=n.invertBatch(w.map(k=>k.pz));return w.map((k,S)=>k.toAffine(B[S])).map(l.fromAffine)})}multiplyUnsafe(d){const w=l.ZERO;if(d===lt)return w;if(i(d),d===ot)return this;const{endo:B}=e;if(!B)return v.unsafeLadder(this,d);let{k1neg:k,k1:S,k2neg:$,k2:H}=B.splitScalar(d),h=w,y=w,A=this;for(;S>lt||H>lt;)S&ot&&(h=h.add(A)),H&ot&&(y=y.add(A)),A=A.double(),S>>=ot,H>>=ot;return k&&(h=h.negate()),$&&(y=y.negate()),y=new l(n.mul(y.px,B.beta),y.py,y.pz),h.add(y)}multiply(d){i(d);let w=d,B,k;const{endo:S}=e;if(S){const{k1neg:$,k1:H,k2neg:h,k2:y}=S.splitScalar(w);let{p:A,f:T}=this.wNAF(H),{p:g,f:p}=this.wNAF(y);A=v.constTimeNegate($,A),g=v.constTimeNegate(h,g),g=new l(n.mul(g.px,S.beta),g.py,g.pz),B=A.add(g),k=T.add(p)}else{const{p:$,f:H}=this.wNAF(w);B=$,k=H}return l.normalizeZ([B,k])[0]}multiplyAndAddUnsafe(d,w,B){const k=l.BASE,S=(H,h)=>h===lt||h===ot||!H.equals(k)?H.multiplyUnsafe(h):H.multiply(h),$=S(this,w).add(S(d,B));return $.is0()?void 0:$}toAffine(d){const{px:w,py:B,pz:k}=this,S=this.is0();d==null&&(d=S?n.ONE:n.inv(k));const $=n.mul(w,d),H=n.mul(B,d),h=n.mul(k,d);if(S)return{x:n.ZERO,y:n.ZERO};if(!n.eql(h,n.ONE))throw new Error("invZ was invalid");return{x:$,y:H}}isTorsionFree(){const{h:d,isTorsionFree:w}=e;if(d===ot)return!0;if(w)return w(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:d,clearCofactor:w}=e;return d===ot?this:w?w(l,this):this.multiplyUnsafe(e.h)}toRawBytes(d=!0){return this.assertValidity(),r(l,this,d)}toHex(d=!0){return mt(this.toRawBytes(d))}}l.BASE=new l(e.Gx,e.Gy,n.ONE),l.ZERO=new l(n.ZERO,n.ONE,n.ZERO);const E=e.nBitLength,v=De(l,e.endo?Math.ceil(E/2):E);return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:f,weierstrassEquation:c,isWithinCurveOrder:s}}function Xr(t){const e=ue(t);return vt(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function Kr(t){const e=Xr(t),{Fp:n,n:r}=e,o=n.BYTES+1,c=2*n.BYTES+1;function s(x){return lt<x&&x<n.ORDER}function i(x){return G(x,r)}function f(x){return Jt(x,r)}const{ProjectivePoint:u,normPrivateKeyToScalar:a,weierstrassEquation:l,isWithinCurveOrder:E}=Wr({...e,toBytes(x,_,R){const m=_.toAffine(),b=n.toBytes(m.x),O=At;return R?O(Uint8Array.from([_.hasEvenY()?2:3]),b):O(Uint8Array.from([4]),b,n.toBytes(m.y))},fromBytes(x){const _=x.length,R=x[0],m=x.subarray(1);if(_===o&&(R===2||R===3)){const b=Et(m);if(!s(b))throw new Error("Point is not on curve");const O=l(b);let U=n.sqrt(O);const N=(U&ot)===ot;return(R&1)===1!==N&&(U=n.neg(U)),{x:b,y:U}}else if(_===c&&R===4){const b=n.fromBytes(m.subarray(0,n.BYTES)),O=n.fromBytes(m.subarray(n.BYTES,2*n.BYTES));return{x:b,y:O}}else throw new Error(`Point of length ${_} was invalid. Expected ${o} compressed bytes or ${c} uncompressed bytes`)}}),v=x=>mt(St(x,e.nByteLength));function I(x){const _=r>>ot;return x>_}function d(x){return I(x)?i(-x):x}const w=(x,_,R)=>Et(x.slice(_,R));class B{constructor(_,R,m){this.r=_,this.s=R,this.recovery=m,this.assertValidity()}static fromCompact(_){const R=e.nByteLength;return _=K("compactSignature",_,R*2),new B(w(_,0,R),w(_,R,2*R))}static fromDER(_){const{r:R,s:m}=Bt.toSig(K("DER",_));return new B(R,m)}assertValidity(){if(!E(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!E(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(_){return new B(this.r,this.s,_)}recoverPublicKey(_){const{r:R,s:m,recovery:b}=this,O=y(K("msgHash",_));if(b==null||![0,1,2,3].includes(b))throw new Error("recovery id invalid");const U=b===2||b===3?R+e.n:R;if(U>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const N=b&1?"03":"02",q=u.fromHex(N+v(U)),Z=f(U),V=i(-O*Z),F=i(m*Z),D=u.BASE.multiplyAndAddUnsafe(q,V,F);if(!D)throw new Error("point at infinify");return D.assertValidity(),D}hasHighS(){return I(this.s)}normalizeS(){return this.hasHighS()?new B(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return Lt(this.toDERHex())}toDERHex(){return Bt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Lt(this.toCompactHex())}toCompactHex(){return v(this.r)+v(this.s)}}const k={isValidPrivateKey(x){try{return a(x),!0}catch{return!1}},normPrivateKeyToScalar:a,randomPrivateKey:()=>{const x=e.randomBytes(n.BYTES+8),_=Vn(x,r);return St(_,e.nByteLength)},precompute(x=8,_=u.BASE){return _._setWindowSize(x),_.multiply(BigInt(3)),_}};function S(x,_=!0){return u.fromPrivateKey(x).toRawBytes(_)}function $(x){const _=x instanceof Uint8Array,R=typeof x=="string",m=(_||R)&&x.length;return _?m===o||m===c:R?m===2*o||m===2*c:x instanceof u}function H(x,_,R=!0){if($(x))throw new Error("first arg must be private key");if(!$(_))throw new Error("second arg must be public key");return u.fromHex(_).multiply(a(x)).toRawBytes(R)}const h=e.bits2int||function(x){const _=Et(x),R=x.length*8-e.nBitLength;return R>0?_>>BigInt(R):_},y=e.bits2int_modN||function(x){return i(h(x))},A=fe(e.nBitLength);function T(x){if(typeof x!="bigint")throw new Error("bigint expected");if(!(lt<=x&&x<A))throw new Error(`bigint expected < 2^${e.nBitLength}`);return St(x,e.nByteLength)}function g(x,_,R=p){if(["recovered","canonical"].some(P=>P in R))throw new Error("sign() legacy options not supported");const{hash:m,randomBytes:b}=e;let{lowS:O,prehash:U,extraEntropy:N}=R;O==null&&(O=!0),x=K("msgHash",x),U&&(x=K("prehashed msgHash",m(x)));const q=y(x),Z=a(_),V=[T(Z),T(q)];if(N!=null){const P=N===!0?b(n.BYTES):N;V.push(K("extraEntropy",P,n.BYTES))}const F=At(...V),D=q;function X(P){const J=h(P);if(!E(J))return;const tt=f(J),nt=u.BASE.multiply(J).toAffine(),W=i(nt.x);if(W===lt)return;const it=i(tt*i(D+W*Z));if(it===lt)return;let pt=(nt.x===W?0:2)|Number(nt.y&ot),_t=it;return O&&I(it)&&(_t=d(it),pt^=1),new B(W,_t,pt)}return{seed:F,k2sig:X}}const p={lowS:e.lowS,prehash:!1},L={lowS:e.lowS,prehash:!1};function j(x,_,R=p){const{seed:m,k2sig:b}=g(x,_,R),O=e;return Ze(O.hash.outputLen,O.nByteLength,O.hmac)(m,b)}u.BASE._setWindowSize(8);function z(x,_,R,m=L){var nt;const b=x;if(_=K("msgHash",_),R=K("publicKey",R),"strict"in m)throw new Error("options.strict was renamed to lowS");const{lowS:O,prehash:U}=m;let N,q;try{if(typeof b=="string"||b instanceof Uint8Array)try{N=B.fromDER(b)}catch(W){if(!(W instanceof Bt.Err))throw W;N=B.fromCompact(b)}else if(typeof b=="object"&&typeof b.r=="bigint"&&typeof b.s=="bigint"){const{r:W,s:it}=b;N=new B(W,it)}else throw new Error("PARSE");q=u.fromHex(R)}catch(W){if(W.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(O&&N.hasHighS())return!1;U&&(_=e.hash(_));const{r:Z,s:V}=N,F=y(_),D=f(V),X=i(F*D),P=i(Z*D),J=(nt=u.BASE.multiplyAndAddUnsafe(q,X,P))==null?void 0:nt.toAffine();return J?i(J.x)===Z:!1}return{CURVE:e,getPublicKey:S,getSharedSecret:H,sign:j,verify:z,ProjectivePoint:u,Signature:B,utils:k}}class Je extends Me{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,ut.hash(e);const r=Yt(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,c=new Uint8Array(o);c.set(r.length>o?e.create().update(r).digest():r);for(let s=0;s<c.length;s++)c[s]^=54;this.iHash.update(c),this.oHash=e.create();for(let s=0;s<c.length;s++)c[s]^=106;this.oHash.update(c),c.fill(0)}update(e){return ut.exists(this),this.iHash.update(e),this}digestInto(e){ut.exists(this),ut.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:c,blockLen:s,outputLen:i}=this;return e=e,e.finished=o,e.destroyed=c,e.blockLen=s,e.outputLen=i,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const tn=(t,e,n)=>new Je(t,e).update(n).digest();tn.create=(t,e)=>new Je(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Qr(t){return{hash:t,hmac:(e,...n)=>tn(t,e,at.concatBytes(...n)),randomBytes:at.randomBytes}}function Jr(t,e){const n=r=>Kr({...t,...Qr(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const en=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),ke=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),ts=BigInt(1),re=BigInt(2),Ue=(t,e)=>(t+e/re)/e;function es(t){const e=en,n=BigInt(3),r=BigInt(6),o=BigInt(11),c=BigInt(22),s=BigInt(23),i=BigInt(44),f=BigInt(88),u=t*t*t%e,a=u*u*t%e,l=M(a,n,e)*a%e,E=M(l,n,e)*a%e,v=M(E,re,e)*u%e,I=M(v,o,e)*v%e,d=M(I,c,e)*I%e,w=M(d,i,e)*d%e,B=M(w,f,e)*w%e,k=M(B,i,e)*d%e,S=M(k,n,e)*a%e,$=M(S,s,e)*I%e,H=M($,r,e)*u%e,h=M(H,re,e);if(!se.eql(se.sqr(h),t))throw new Error("Cannot find square root");return h}const se=Fe(en,void 0,void 0,{sqrt:es}),ns=Jr({a:BigInt(0),b:BigInt(7),Fp:se,n:ke,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=ke,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-ts*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),c=n,s=BigInt("0x100000000000000000000000000000000"),i=Ue(c*t,e),f=Ue(-r*t,e);let u=G(t-i*n-f*o,e),a=G(-i*r-f*c,e);const l=u>s,E=a>s;if(l&&(u=e-u),E&&(a=e-a),u>s||a>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:u,k2neg:E,k2:a}}}},Ge);BigInt(0);ns.ProjectivePoint;var $t={},nn={};(function(t){Object.defineProperty(t,"__esModule",{value:!0}),t.hmac=t.HMAC=void 0;const e=et,n=at;class r extends n.Hash{constructor(s,i){super(),this.finished=!1,this.destroyed=!1,e.default.hash(s);const f=(0,n.toBytes)(i);if(this.iHash=s.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const u=this.blockLen,a=new Uint8Array(u);a.set(f.length>u?s.create().update(f).digest():f);for(let l=0;l<a.length;l++)a[l]^=54;this.iHash.update(a),this.oHash=s.create();for(let l=0;l<a.length;l++)a[l]^=106;this.oHash.update(a),a.fill(0)}update(s){return e.default.exists(this),this.iHash.update(s),this}digestInto(s){e.default.exists(this),e.default.bytes(s,this.outputLen),this.finished=!0,this.iHash.digestInto(s),this.oHash.update(s),this.oHash.digestInto(s),this.destroy()}digest(){const s=new Uint8Array(this.oHash.outputLen);return this.digestInto(s),s}_cloneInto(s){s||(s=Object.create(Object.getPrototypeOf(this),{}));const{oHash:i,iHash:f,finished:u,destroyed:a,blockLen:l,outputLen:E}=this;return s=s,s.finished=u,s.destroyed=a,s.blockLen=l,s.outputLen=E,s.oHash=i._cloneInto(s.oHash),s.iHash=f._cloneInto(s.iHash),s}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}t.HMAC=r;const o=(c,s,i)=>new r(c,s).update(i).digest();t.hmac=o,t.hmac.create=(c,s)=>new r(c,s)})(nn);Object.defineProperty($t,"__esModule",{value:!0});$t.pbkdf2Async=$t.pbkdf2=void 0;const jt=et,rs=nn,Ht=at;function rn(t,e,n,r){jt.default.hash(t);const o=(0,Ht.checkOpts)({dkLen:32,asyncTick:10},r),{c,dkLen:s,asyncTick:i}=o;if(jt.default.number(c),jt.default.number(s),jt.default.number(i),c<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const f=(0,Ht.toBytes)(e),u=(0,Ht.toBytes)(n),a=new Uint8Array(s),l=rs.hmac.create(t,f),E=l._cloneInto().update(u);return{c,dkLen:s,asyncTick:i,DK:a,PRF:l,PRFSalt:E}}function sn(t,e,n,r,o){return t.destroy(),e.destroy(),r&&r.destroy(),o.fill(0),n}function ss(t,e,n,r){const{c:o,dkLen:c,DK:s,PRF:i,PRFSalt:f}=rn(t,e,n,r);let u;const a=new Uint8Array(4),l=(0,Ht.createView)(a),E=new Uint8Array(i.outputLen);for(let v=1,I=0;I<c;v++,I+=i.outputLen){const d=s.subarray(I,I+i.outputLen);l.setInt32(0,v,!1),(u=f._cloneInto(u)).update(a).digestInto(E),d.set(E.subarray(0,d.length));for(let w=1;w<o;w++){i._cloneInto(u).update(E).digestInto(E);for(let B=0;B<d.length;B++)d[B]^=E[B]}}return sn(i,f,s,u,E)}$t.pbkdf2=ss;async function os(t,e,n,r){const{c:o,dkLen:c,asyncTick:s,DK:i,PRF:f,PRFSalt:u}=rn(t,e,n,r);let a;const l=new Uint8Array(4),E=(0,Ht.createView)(l),v=new Uint8Array(f.outputLen);for(let I=1,d=0;d<c;I++,d+=f.outputLen){const w=i.subarray(d,d+f.outputLen);E.setInt32(0,I,!1),(a=u._cloneInto(a)).update(l).digestInto(v),w.set(v.subarray(0,w.length)),await(0,Ht.asyncLoop)(o-1,s,B=>{f._cloneInto(a).update(v).digestInto(v);for(let k=0;k<w.length;k++)w[k]^=v[k]})}return sn(f,u,i,a,v)}$t.pbkdf2Async=os;export{Ge as a,ft as b,Ut as c,is as e,$t as p,ns as s,at as u};
